;Title                 		BAA RAG Controller Module
;
;Status                 	Non-Release Version 0.1
;
;Written by             	David Farn
;Date Started           	12th November 2006
;Release Date           	TBA
;File Saved as          	CONTRL23.DOC
;Device Description		Futurlec ADuC832 Controller Board
;Processor              	Analogue Devices ADuC832 with 8052 Core
;Clock                  	Programmable PLL based on 32KHz crystal oscillator
;Instruction Rate		Core Clock / 12
;Watchdog			Disabled
;Code Protection 		Off
;Purpose                	To provide interface between Starbase PnP instruments
;				and the user PC. Local control and data Logging when
; 				appropriate.
;
;				Communications to Starbase is via RS485 using Staribus
;				protocol
;
;Customer               	BAA RAG
;
;History                	12/11/2006 - Framework program laid out to test
;			  	assembler/downloader
;
;				16/11/2006 - First successful assembly using ASEM with
;				ADuC832 symbols
;
;				05/06/2007 - Controller boxed for test and development
;				Staribus protocol developed to sufficient level to
;				enable meaningful progress to be made with communications
; 				routines.
;
;				20/8/2007 - Having developed a test program to exercise
;				as many functions of the ADuC controller board as
;				possible and then used the routines to develop a logger
;				for use with the BAA RAG VLF receiver, the lessons
;				learned have been brought into the Starbase VLF
;				controller/logger.
;
;				7 bit Even Parity serial communications
;
;				28/08/2007 - CONTRL04 was the first version to
;				successfully exchange Starbase formatted messages.
;				It was realised that in order to format data to & from
;				XML memory for display, using the CR character would
;				cause problems. Version 05 introduces the EOT character
;				to terminate messages.
;
;				07-09-2007 Version 6 places dmsformat separator characters
;				between the sections of the message strings, adds
;				interrupt driven logging so that the controller can
;		 		respond to messages while in logging mode and looks for
; 				instrument module EEPROM data to identify and initiate
;	 			appropriate software.
;
;				24/09/2007 Version 7 Takes the 'almost' complete code
;				and applies an audit. Common routines have been replaced
;				by calls to new sub-routines.Response status information
;				is improved and some parameter checking applied.
;
;				30/09/2007 Version 8 Adds Function 1 routines associated
;				with the VLF reciever.
;
;				28/10/2007 Version 9 does not add functionality but a
;				comprehensive tidy up exercise could have introduced
;				bugs. Fall back is to V8. VLF Logging routines completed
;				and this should be the final version before release to
;				Laurence Newell for evaluation.
;
;				16/11/2007 Following meeting at Space Centre and issue
;				of controller to Laurence Newell it was clear the another
;				significant reworking of the command grouping, date
;				format and message string terminator character (now 04h)
;				was required. This coinsided with the introduction of an
;				I2C LCD display for which drivers were required along with
;				code insertions where necessary.
;
;				06/02/2008 Although the controller was working with all
;				commands except getConfig and getLoggedData, Laurence Newell
;				had concerns about the interface with Starbase. To improve
;				error detection at the transport level and facilitate
;				larger data blocks, it was decided to change the LRC error
;				check to a CRC check using the CRC CCITT Polynomial. Some
;				other changes in command order were also made at the
;				request of LN.
;
;				13/02/2008 CRC routines working after some issues around
;				the reuse of the general purpose registers R0 - R7.
;
;				24/02/2008 Version 20 makes radical changes to boot sequence.
;				Required to make getConfig instructions work by taking
;				XML from each EEPROM and to allow for instrument specific
;				software to run to support operation of the instrument. Also
;				made changes to buffer sizes and locations in XRAM to allow
;				for 512 byte block sizes which take more than 1k characters
;				to handle in ASCII.
;
;				04/06/08 Versions 21 and 22 largely were concerned with
;				getConfig instructions and the definition of the instrument
;				in XML held in EEPROM. This is not fully completed at this
;				stage. The availability of a dummy magnetometer connected by
;				I2C has allowed instructions to be added to the magnetometer
;				operating system to read and write to the gain switch.
;
;				10/06/08 Version 23 Includes fully working routines for the
;				magnetometer and upgrades to the LCD routines. Latest
;				discussions about logging are being turned into routines in
;				this version.
;
;				24/07/08 Version 24 Has all routines for logging the
;				magnetometer and will eventually have logging for a RAG VLF
;				Receiver. Temperature measurement using the LM73 sensor has
;				been added for the magnetometer. All Starbase commands for the
;				magnetometer including temperature are working,
;
;				09/08/08 Version 25 was introduced to back up the improvements
;				made to version 24 but also adds working logging and
;				getConfigMaxBlock. The RTOS from magnetometer has been copied
;				to the VLF Version 01 code area and the logging section
;				modified to capture ADC Channel 0.
;
;				22/08/08 Version 26 includes working code for getConfig. This
;				means that all Command functions are working for the VLF Rx and
;				magnetometer. Logging is fully operational but may require some
;				further work depending upon the outcome of a design review
;				to be carried out with Laurence Newall. The main consideration
;				is logging of temperature.
;
;
;===========================================================================================
;	Hardware Configuration Information
;===========================================================================================
;
;Internal RAM			The ADUC has 256 bytes of RAM from address 00h to FFh
;				Four register banks each storing 8 registers R0 to R7
;				occupy addresses 00h to 1fh.
;
;				The addresses between 20h and 2Fh are directly bit
;				addressable and can be used effectively for bit testing
;				and manipulation. The bit addresses range is 00h to 7Fh.
;
;				General purpose RAM starts at 30h. Between 30h and 7Fh
;				the RAM is directly or indirectly addressable. Between
;				80h and FFh the RAM is only indirectly addressable and
;				may be best suited to hold the Stack data.
;
;Special Function
;Registers (SFRs)		Special function registers hold configuration and status
;				information. They occupy the same address space as upper
;				RAM but are only Directly addressable. Addresses ending
;				X0h and	X8h are bit addressable in the range 80h to FFh.
;
;External RAM			The ADuC832 has 2k of RAM that is addressed as external
;				memory despite it being 'on-chip'. In addition, the
;				parallel ports can be used as address and data bus
;				connections to address up to 16M byte of 'off-chip'
;				external RAM. The Futurlec ADuC controller board has
;				socketed space for 1M byte of RAM. The addressing range
;				is 00000h to FFFFFh.
;
;				RS485 serial routines use 00000h to 007FFh (2k byte)
;				as a input buffer.
;
;				RS485 serial routines use 00800h to 00FFFh (2k byte)
;				as an output buffer.
;
;				I2C Routines use 01000h to 013FFh (1K byte) as a
;				buffer.
;
;				Routines may use 01400h to 017FFh (1k byte) as
;				general buffer space.
;
;				Logging uses memory from 01800h to FFFFFh.
;
;Code Memory			The ADuC832 can use internal or external instruction
;				memory. The RAG controller will use internal code
;				memory between 0000h and F7FFh (62k bytes).
;
;				Because interrupt vectors occupy the bottom of code
;				memory space, program code should start at 00060h or
;				above. The Reset vector address at 00000h should contain
;				a jump to this address.
;
;Interrupts			Interrupts force the control program to specific code
;				memory addresses.
;
;				Reset Vector			00000h
;				External Interrupt 0 		00003h
;				Timer 0 Interrupt		0000Bh
;				External Interrupt 1		00013h
;				Timer 1 Interrupt		0001Bh
;				UART Interrupt			00023h
;				Timer 2 Interrupt		0002Bh
;				ADC Conversion End Interrupt	00033h
;				I2C Interrupt			0003Bh
;				Power Supply Interrupt		00043h
;				Time Interval Counter Interrupt	00053h
;				Watchdog Timer Interrupt	0005Bh
;
;===========================================================================================
;			Software Notes
;===========================================================================================
;
;Status Word designations	The 16 bit status word returned to the Starbase PC by the
;				controller is defined as follows:-
;
;				Word	Error			CONSTATHI  CONTSTATLO
;				----    -----                   ---------  ----------
;				0x0000	Success			  00h	     00h
;				0x0001	Timeout			  00h	     01h
;				0x0002	Abort			  00h	     02h
;				0x0004	Premature Termination	  00h	     04h
;				0x0008	Invalid Parameter	  00h	     08h
;				0x0010	Invalid Message	  	  00h	     10h
;				0x0020	Invalid Command		  00h	     20h
;				0x0040	Invalid Module		  00h	     40h
;				0x0080	Invalid Instrument	  00h	     80h
;
;				0x0100	Module Databus Error	  01h	     00h
;				0x0200	Rx CRC Err (SB Internal)  02h	     00h
;				0x0400	Error 09 - Not defined	  04h	     00h
;				0x0800	Error 12 - Not defined	  08h	     00h
;				0x1000	Error 13 - Not defined	  10h	     00h
;				0x2000	Error 14 - Not defined	  20h	     00h
;				0x4000	Error 15 - Not defined	  40h	     00h
;				0x8000	Logging Active	  	  80h	     00h
;
;General Purpose Register
;Bank Allocation		Bank 0 - TBD
;
;				Bank 1 - TBD
;
;				Bank 2 - TBD
;
;				Bank 3 - TBD
;
;===========================================================================================
;			Configure Assembler
;===========================================================================================
				;
$NOMOD51			; Turn off 8051 predefined symbols
$INCLUDE (ADUC832.MCU)       	; Turn on ADuC832 predefined symbols
				;
;===========================================================================================
;                  	Define Variables in Internal RAM
;===========================================================================================
;
;Place variables in the general purpose area of lower RAM - 30h to 7fh
;
CONTADD		DATA	30h	; Controller Staribus network address
RCVDADD		DATA	31h	; Address received with command
				;
CODEBASE	DATA	32h	; Received Command Function
CMDCODE		DATA	33h	; Received Command Sub Function
CONTSTATHI	DATA	34h	; Controller Status top 8 bits used in response
CONTSTATLO	DATA	35h	; Controller Status bottom 8 bits
CALCPAR		DATA	36h	; Serial input calculated parity
RXDATABUF	DATA	37h	; Serial input data buffer
ENDOFBUFHI	DATA	38h	; Position of CRC HI
ENDOFBUFLO	DATA	39h	; Position of CRC LO
CRCHI		DATA	3Ah	; CRC High Byte
CRCLO		DATA	3Bh	; CRC LOw Byte
				;
INSTRUMENT	DATA	3Ch	; Instrument type 01=VLF
VERSION		DATA	3Dh	; Instrument Version
				;
MODULE		DATA	3Eh	; EEPROM I2C ADDRESS
BITCNT 		DATA 	3Fh 	; Bit counter for I2C routines
I2CRXBUF	DATA	40h	; I2C Receiver Buffer
				;
TENHOURS	DATA	41h	; Tens of Hours
HOURS		DATA  	42h	; Unit of Hours
TENMINUTES	DATA  	43h	; Tens of Minutes
MINUTE		DATA  	44h	; Unit of Minute
TENSECONDS	DATA  	45h	; Tens of Seconds
SECOND		DATA  	46h	; Unit of Seconds
TENDATE		DATA	47h	; Tens of Days
DATE		DATA	48h	; Unit of Day
TENMONTH	DATA	49h	; Tens of Months
MONTH		DATA	44h	; Unit of Month
TENYEAR		DATA  	45h	; Tens of Years
YEAR		DATA  	46h	; Unit of years
CENTTEN		DATA	4Dh	; Tens of Century
CENTUNIT	DATA	4Eh	; Units of Century
				;
EEPROMH		DATA	4Fh	; EEPROM Page boundary
EEPROML		DATA	50h	; EEPROM Page boundary
XRCOUNT		DATA	51h	; Loop Counter
 				;
PERIODHI	DATA	52h	; Logging sample time High Byte
PERIODLO	DATA	53h	; Logging sample time Low Byte
BLOCKHI		DATA	54h	; Logging block counter
BLOCKLO		DATA	55h	; Logging block counter
SAMCOUNT	DATA	56h	; Logging Sample Counter
LOGPTRPG	DATA	57h	; Logging Pointer Page
LOGPTRHI	DATA	58h	; Logging Pointer Hign
LOGPTRLO	DATA	59h	; Logging Pointer Low
				;
DEMAND0H	DATA	52h	; Antenna Demanded Position
DEMAND0L	DATA	53h	;
DEMAND1H	DATA	54h	;
DEMAND1L	DATA	55h	;
				;
DACVALH		DATA	5Ah	; DAC Hi Byte
DACVALL		DATA	5Bh	; DAC Lo Byte
DACCHAN		DATA	5Ch	; DAC Channel pointer
A2DCHANNEL	DATA	5Dh	; Current A2D Channel
				;
PROMMAP		DATA	5Eh	; Maps EEPROMS available B0=A0h B7=AEh
INPTRHI		DATA	5Fh	; get Config/EEPROM Pointer
INPTRLO		DATA	60h	; get Config/EEPROM Pointer
OUTPTRHI	DATA	61h	; get Config Pointer
OUTPTRLO	DATA	62h	; get Config Pointer
CFGBLKHI	DATA	63h	; get Config Block Size Register Hi
CFGBLKLO	DATA	64h	; get Config Block Size Register Lo
CFGBLKMAXHI	DATA	65h	; Total XML Block Size Calculated at boot-up
CFGBLKMAXLO	DATA	66h	; Total XML Block Size Calculated at boot-up
				;
VARA		DATA	67h	; Used in BCD Calc
VARB		DATA	68h	; Used in BCD Calc
VARC		DATA	69h	; Used in BCD Calc
VARD		DATA	6Ah	; Used in BCD Calc
ADH		DATA	6Bh	; Used in BCD Calc
ADL		DATA	6Ch	; Used in BCD Calc
				;
SCALEA		DATA	6Dh	; Bin to Dec scaling Hi
SCALEB		DATA	6Eh	; Bin to Dec scaling Lo
				;
STACKHI		DATA	6Fh	; Stack Pointer High
STACKLO		DATA	70h	; Stack Pointer Low
LOOPCOUNT	DATA	71h	; Loop Counter
				;
NOACK 		BIT 	00h 	; I2C no acknowledge flag
BUFACTV		BIT	01h	; Buffer Active Flag bit
RXSTRGAV	BIT	02h	; RX String Data Available
BUFORERR	BIT	03h	; Input Buffer Overrun Error Flag bit
VALIDHEX	BIT 	04H	; Set if valid Hex character (CHKHEX)
LASTBYTE	BIT	05h	; Last byte in I2C frame Flag
BUFEMPTY	BIT	06h	; Tx Buffer Empty Flag
PARITYFLAG	BIT	07h	; RS485 Character Parity Error Flag
NEWBLOCK	BIT	08h	; New Logging Block Flag
LOGEN		BIT	09h	; Logging Flag
COUNT257	BIT	0Ah	; Used to hold overflow in XML SET
SENDNOCRC	BIT	0Bh	; If set, miss CRC update in character send
EOTERR		BIT	0Ch	; If set EOT not found in EEPROM
STRINGERR	BIT	0Dh	; Flag error in string from interupt
NEGVAL		BIT	0Eh	; Negative Value Indicator
LCDLOCAL	BIT	0Fh	; Set if LCD display is showing local data
CNTRLFLAG	BIT	10h	; Local controls input flag
TIMERFLAG	BIT	11h	; Logging timer end of period
EXISTINGLOG	BIT	12h	; Flag to show that a log exists (Onetime)
T0FLAG		BIT	13h	; Flag set by Timer 0 interupt routine
				;
;
;======================================================================
;     List of Staribus Functions
;======================================================================
;
;   ADuC832 Controller
;
;   Controller Core
;
;	Command 	Routine		Starbase Name	  Purpose
;
;	CB00 CC00	n/a		reset		  Soft Controller Restart
;	CB00 CC01	PING		ping 		  Controller validity test
;	CB00 CC02	GETCNFG		getConfig  	  Read instrument XML Config
;							  A virtual command not sent
;							  to controller
;	CB00 CC03	GETCNFGMAX	getConfigMaxBlock Returns size of instrument
;							  XML config data
;	CB00 CC04	GETCNFGDATA	getConfigBlock	  Returns requested 512 byte
;							  data block
;
;   Controller Utilities
;
;	CB01 CC00	GETRTCDATE	getClockDate	  Read RTC Date
;	CB01 CC01	SETRTCDATE	setClockDate 	  Write RTC Date
;	CB01 CF02	GETRTCTIME	getClockTime 	  Read RTC Time
;	CB01 CF03	SETRTCTIME	setClockTime	  Write RTC Time
;	CB01 CC04	GETCPUTEMP	getTemperature    Read CPU Temperature
;	CB01 CC05	GETEEPROM 	N/A		  Read EEPROM Page (non SB)
;	CB01 CC06	SETEEPROM	N/A		  Write EEPROM Page (non SB
;
;   Analogue Virtual Module
;
;	CB02 CC00	GETVALA2D 	getA2D		  Read A2D Input
;	CB02 CF01	GETVALD2A	getD2A		  Read back set D2A value
;	CB02 CC02	SETVALD2A	setD2A		  Set D2A value
;
;   Logger Virtual Module
;
;	Command 	Routine		Starbase Name	  Purpose
;
;	CB03 CC00	GETSPACE	getSpace	  Returns percentage of
;							  available storage
;	CB03 CC01	GETLOGDATA	getData	  	  Download logged data
;							  A virtual command not sent
;							  to controller
;	CB03 CC02	GETMAXBLOCK	getDataBlockCount Read last data block number
;	CB03 CC03	GETDATABLOCK	getDataBlock	  Read data block
;	CB03 CC04	GETRATE		getRate	  	  Read logging sample rate
;	CB03 CC05	SETRATE		setRate		  Write logging sample rate
;	CB03 CC06	CAPTURE		capture	  	  Start and stop the logger
;
;   Broadcast Functions
;
;	Command 	Routine		Starbase Name	  Purpose
;
;	CB00 CC00       DISCOVER	Discover	  Find Staribus connected
;							  Controllers. Uses broadcast
;							  address 0FEh
;
;===========================================================================================
; 			Start of Code
;===========================================================================================
					  	;
CSEG					  	;
ORG 0000h				  	; Define Reset Address
		JMP 	INITPROG	  	; Jump to start of program
					 	;
;===========================================================================================
;			Interrupt Routines
;===========================================================================================
					  	;
ORG 0003h				  	;
		RETI			  	; External Interrupt 0
					  	;
ORG 000Bh				  	;
		JMP	TIMER0INT  		; Timer 0 Interrupt
					  	;
ORG 0013h				  	;
		RETI			  	; External Interrupt 1
					  	;
ORG 001Bh				  	;
		RETI			  	; Timer 1 Interrupt
					  	;
;-------------------------------------------------------------------------------------------
					  	;
ORG 0023h				  	;
		JMP	UARTINT		  	; UART Interrupt
					  	;
;-------------------------------------------------------------------------------------------
		 			  	;
ORG 002Bh				  	;
		RETI			  	; Timer 2 Interrupt
					  	;
ORG 0033h	 			  	;
		RETI			  	; ADC Conversion Interrupt
					  	;
;-------------------------------------------------------------------------------------------
					  	;
ORG 003Bh				  	;
		RETI			  	; I2C Interrupt
					  	;
ORG 0043h	 			  	;
		RETI			  	; Power Interrupt
					  	;
;-------------------------------------------------------------------------------------------
					  	;
ORG 0053h				  	;
		JMP	INTERVALINT	  	; Interval timer
					  	;
ORG 005Bh				  	;
		RETI			  	; Watchdog Timer Interrupt
					  	;
;===========================================================================================
;			Main Program Start
;===========================================================================================
					 	;
ORG 0060h				  	; Main program starts at 0060h above
					  	; Interrupt Vectors
					  	;
;
; ******************************************************************************************
; *  			Initialise Controller and Peripherals                              *
; ******************************************************************************************
					  	;
INITPROG:				  	;
					  	;
;Set AuDC Clock and test for correct
;Operation
		MOV	PLLCON,#00h	  	; Set Core Clock Speed to 16.777216MHz
					  	;
Lock:		MOV	A,PLLCON	  	; Get Clock PLL SFR
		ANL	A,#40h		  	; Mask PLL Lock Indicator
		JZ	Lock		  	; Loop until PLL locked
					  	;
;Configure XRAM
;
		MOV	CFG832,#01h   	  	; Configure Processor Parmeters
					  	; Give access to internal XRAM (2kB)
					  	;
;Configure Stack Pointer
;
		MOV	SP,#80h		  	; SET Stack Pointer to 80h to give 128
					  	; bytes at top of internal ram
					  	;
;Configure the UART ADuC832
;
		MOV 	SCON,#52h 	  	; configure UART for 8bit (7 data+Parity)
		MOV 	T3CON,#85h 	  	; at 9600baud Using timer 3
		MOV 	T3FD,#2Dh	  	;
					  	;
;Configure & enable interrupts
;
		MOV	IP,#10h			; Make UART Interupt High Priority
		SETB 	ES		  	; enable UART Interrupt
		ORL	IEIP2,#14h	  	; Set ETI bit enable Time Interval Interupt
		SETB	EA		  	; enable interrupts
						;
;Configure ADC
;
		MOV	ADCCON1,#0ACh	  	; Set ADCCON1 Register
		MOV	ADCCON2,#08h	  	; Set ADCCON2 Register Select Temp Mon
		MOV	ADCCON3,#30h	  	; Set ADCCON3 Register
		MOV	A2DCHANNEL,#00h   	; Set default input channel to 0
					  	;
;Configure DAC
;
		MOV	DACCON,#1Fh	  	; Turn on DAC0 and DAC1
		MOV	DAC0H,#03h	  	; Set DAC ouput to 1.00V
		MOV	DAC1H,#06h	  	;
		MOV	DAC0L,#33h	  	;
		MOV	DAC1L,#67h	  	;

;Configure I2C
;
		MOV	A,#0A8h		  	; Set I2C Control Register
		MOV	I2CCON,A	  	;
		SETB	I2CRS		  	; Reset I2C
		CALL	I2CDELAY	  	;
		CLR	I2CRS		  	;
		CALL	I2CDELAY	  	;
					  	;
;Initialise Program
;
		CLR	A		  	; Select Main DPTR mode
		MOV	DPCON,A		  	;
		CLR	RS1			; Select Bank 0 of registers
		CLR	RS0			;
		CLR 	BUFACTV		  	; Make receive buffer inactive
		CLR	BUFORERR	  	; Clear buffer over run flag
		CLR	RXSTRGAV	  	; Clear Rx String DAV Flag
		CLR	LOGEN		  	; Clear Loging Mode Flag
		CLR	EXISTINGLOG		; Clear onetime log flag
		CLR	NOACK		  	; Clear I2C Ack flag
		SETB	BUFEMPTY	  	; TX Buffer Empty Flag
		CLR	SENDNOCRC		; Clear skip CRC update flag
		MOV	PERIODHI,#00h		; Set default logging period 5s
		MOV	PERIODLO,#05h       	;
		MOV	CONTSTATLO,#00h     	; Set default controller status
		MOV	CONTSTATHI,#00h		;
		MOV	LOGPTRPG,#00h		; Reset Logging Pointer
		MOV	LOGPTRHI,#18h		;
		MOV	LOGPTRLO,#00h		; Makes getSpace work correctly
						;
;Initialise RTC
;
		CLR	LASTBYTE	  	;
		CALL	STARTBIT	  	;
		MOV	A,#0D0h		  	; DS1307 Address + Write
		CALL	SENDBYTE	  	;
		MOV	A,#0Ah		  	; Select Valid Config
		CALL	SENDBYTE	  	;
		CALL	STARTBIT	  	; Stop Write and start read
		MOV	A,#0D1h		  	; DS1307 Address + Read
		CALL	SENDBYTE	  	;
		SETB	LASTBYTE		; Flag last read
		CALL	RCVBYTE		  	; Get Valid Config
		MOV	VARA,I2CRXBUF		; Save
		CALL	STOPBIT		  	;
		MOV	A,#55h			; 55h shows that RTC has config
		CJNE	A,VARA,RTCNOCFG		; Compare and jump if no config
						;
		JMP	INITLCD			;
						;
RTCNOCFG:	CALL	STARTBIT	  	; Set default date to 2000-01-01
		MOV	A,#0D0h		  	; DS1307 Address + Write
		CALL	SENDBYTE	  	;
		MOV	A,#04h		  	; Select Date register
		CALL	SENDBYTE	  	;
		MOV	A,#01h		  	;
		CALL	SENDBYTE	  	; Set Days Register
		MOV	A,#01h		  	;
		CALL	SENDBYTE	  	; Set Month Register
		MOV	A,#00h		  	;
		CALL	SENDBYTE	  	; Set Years Register
		MOV	A,#00h			; Set RTC COntrol Register
		CALL	SENDBYTE		;
		MOV	A,#32h			; Set Tens of Centuries = 20
		CALL	SENDBYTE		;
		MOV	A,#30h			; Set Centuries = 00
		CALL	SENDBYTE		;
		MOV	A,#55h			; Set config marker
		CALL	SENDBYTE		;
		CALL	STOPBIT		  	;
					  	;
;Initialize LCD
;
INITLCD:	CLR	LCDLOCAL		;
						;
		CALL	STARTBIT	  	; Start I2C comms
		MOV	A,#76h		  	; Send LCD Address
		CALL	SENDBYTE	  	;
		MOV	A,#80h		  	; Send Multi Control Byte
		CALL	SENDBYTE	  	;
		MOV	A,#25h		  	; Set LCD Function H=1
		CALL	SENDBYTE	  	;
		MOV	A,#00h		  	; Send Single Control Byte
		CALL	SENDBYTE	  	;
		MOV	A,#0A0h		  	; Set LCD Volts
		CALL	SENDBYTE	  	;
		CALL	STOPBIT		  	;
		CALL	STARTBIT	  	;
		MOV	A,#76h		  	; Send LCD Address
		CALL	SENDBYTE	  	;
		MOV	A,#80h		  	; Send Multi Command Byte
		CALL	SENDBYTE	  	;
		MOV	A,#24h  	  	; Set LCD Function H=0
		CALL	SENDBYTE	  	;
		MOV	A,#80h		  	; Send Multi Command Byte
		CALL	SENDBYTE	  	;
		MOV	A,#0Ch		  	; Turn Display ON - No Cursor
		CALL	SENDBYTE	  	;
		MOV	A,#00h		  	; Send Single Command Byte
		CALL	SENDBYTE	  	;
		MOV	A,#06h		  	; Set Entry Mode
		CALL	SENDBYTE	  	;
		CALL	STOPBIT		  	; Stop I2C Comms
		CALL	CLEARLCD	  	; Clear Display DDRAM
					  	;
;Write Message to LCD
;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'> Astrometrics <'  	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	' Copyright 2008 '  	;
		DB	03h		  	;
		CALL	LONGDELAY		;
		CALL	LONGDELAY		;
						;
		CALL	CLEARLCD		;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Starbase        '  	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Controller      ' 	;
		DB	03h		  	;
		CALL	LONGDELAY		;
		CALL	LONGDELAY		;
						;
		CALL	CLEARLCD		;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Beta Test       '  	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Version B0.01   ' 	;
		DB	03h		  	;
		CALL	LONGDELAY		;
		CALL	LONGDELAY		;
						;
		CALL	CLEARLCD		;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Connected Module'  	;
		DB	03h		  	;
						;
		CALL	LONGDELAY		;
;
;Test for controller EEPROM
;
		MOV	MODULE,#0A0h	  	; Set module to controller EEPROM Address
		MOV	EEPROMH,#00h	  	; Set pointer to read page 0
		MOV	EEPROML,#00h	  	;
		CLR	NOACK			; Clear error flag
		CALL	READEEPROM	  	; Read first 128 bytes of EEPROM to Buffer
		JNB	NOACK,RDCONTAD      	; If EEPROM data ok jump
					  	;
		CLR	NOACK		  	; If errored read reset error flag
		MOV	CONTADD,#80h	  	; Assume no EEPROM, set address to 80h
		MOV	INSTRUMENT,#00h   	; and set invalid instrument data
		MOV	VERSION,#00h	  	;
						;
 		JMP	INITCWNPROM		; Jump to miss configuration that needs a
						; controller EEPROM. Only core will work.
						;
;
;Set Address and test for 1st Instrument EEPROM that defines instrument type
;
						;
RDCONTAD:	MOV	DPP,#00h	  	; Set buffer data pointer to address data
		MOV	DPH,#0Fh	  	;
		MOV	DPL,#0FFh	  	;
		CALL	READBYTE	  	; Get controller address held in EEPROM
		JNZ	GOODADD			; If illegal address 00h use default 80h
						;
		MOV	A,#80h			; Default = 80h
GOODADD:	MOV	CONTADD,A		; Set Controller Staribus Address
						;
		MOV	MODULE,#0A2h	  	; Set module to controller EEPROM Address
		MOV	EEPROMH,#00h	  	; Set pointer to read page 0
		MOV	EEPROML,#00h	  	;
		CLR	NOACK			; Clear error flag
		CALL	READEEPROM	  	; Read first 128 bytes of EEPROM to Buffer
		JNB	NOACK,RDINSTRUM      	; If EEPROM data ok jump
					  	;
		CLR	NOACK		  	; If errored read reset error flag
		MOV	INSTRUMENT,#00h   	; and set invalid instrument data
		MOV	VERSION,#00h	  	;
 		JMP	INITCWPROM		; No instrument
						; Jump to controller with EEPROM
						; Only core will work.
						;
;Read Instrument type and version
;
						;
RDINSTRUM:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Searching for   ' 	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Instrument      '      ;
		DB	03h			;
		CALL	LONGDELAY		;
					  	;
		MOV	DPP,#00h	  	; Set Data Pointer to EEPROM data
		MOV	DPH,#0Fh	  	;
		MOV	DPL,#0FFh	  	;
		CALL	READBYTE	  	; Get Instrument type from EEPROM
		MOV	INSTRUMENT,A	  	; and save
		CALL	READBYTE	  	; Get Instrument type from EEPROM
		MOV	VERSION,A	  	; and save
						;
;
;Determine which instrument is connected
;
		MOV	A,INSTRUMENT		;
		CJNE	A,#01h,TRYMAG		; Jump if not VLF Rx
						;
		CALL	CLEARLCD		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'VLF RX'		;
		DB	03h			;
		MOV	A,VERSION		;
		CJNE	A,#01h,NOTVLF01		; Jump if not VLF version 01
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Version 01'		;
		DB	03h			;
		CALL	LONGDELAY		;
		JMP	INITVLF01		; Jump to VLF Rx Version 01
						;
NOTVLF01:	CJNE	A,#02h,QJUMP1		; Jump of not VLF version 02
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Version 02'		;
		DB	03h			;
		CALL	LONGDELAY		;
		JMP	INITVLF02		; Jump to VLF Rx Version 02
						;
QJUMP1:		JMP	BADINSTRMNT		;
						;
TRYMAG:		CJNE	A,#02h,TRY21CM		; Test for Magnetometer
						;
		CALL	CLEARLCD		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Magnetometer'		;
		DB	03h			;
		MOV	A,VERSION		;
		CJNE	A,#01h,QJUMP2		; Jump if not Mag version 01
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Version 01'		;
		DB	03h			;
		CALL	LONGDELAY		;
		JMP	INITMAG01		; Jump to Mag Rx Version 01
						;
QJUMP2:		JMP	BADINSTRMNT		;
						;
TRY21CM:	CJNE	A,#03h,TRYCLOCK		; Test for 21CM Receiver
						;
		CALL	CLEARLCD		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'21CM Receiver'		;
		DB	03h			;
		MOV	A,VERSION		;
		CJNE	A,#01h,QJUMP3		; Jump if not Mag version 01
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Version 01'		;
		DB	03h			;
		CALL	LONGDELAY		;
		JMP	HYDROGEN01		; Jump to 21CM Rx Version 01
						;
QJUMP3:		JMP	BADINSTRMNT		;
						;
TRYCLOCK:	CJNE	A,#04h,TRYANTCNTRL	; Test for Clock
						;
		CALL	CLEARLCD		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Clock'		        ;
		DB	03h			;
		MOV	A,VERSION		;
		CJNE	A,#01h,QJUMP4		; Jump if not Mag version 01
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Version 01'		;
		DB	03h			;
		CALL	LONGDELAY		;
		JMP	CLOCK01			; Jump to Clock Version 01
						;
QJUMP4:		JMP	BADINSTRMNT		;
						;
TRYANTCNTRL:	CJNE	A,#05h,UNKNOWNINST	; Test for Antenna Controller
						;
		CALL	CLEARLCD		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Antenna Control'	;
		DB	03h			;
		MOV	A,VERSION		;
		CJNE	A,#01h,QJUMP5		; Jump if not Mag version 01
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Version 01'		;
		DB	03h			;
		CALL	LONGDELAY		;
		JMP	ANTCNTRL01		; Jump to Antenna Controller Version 01
						;
QJUMP5:		JMP	BADINSTRMNT		;
						;
UNKNOWNINST:	MOV	A,#00h			; 1st line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display error message on LCD
		DB	'Unknown         '	;
		DB	03h			;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		;
		DB	'Instrument type '	;
		DB	03h			;
		CALL	LONGDELAY		;
		CALL	LONGDELAY		;
		JMP	INITCWPROM		;
						;
BADINSTRMNT:	MOV	A,#00h			; 1st line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display error message on LCD
		DB	'Unknown         '	;
		DB	03h			;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		;
		DB	'Instrument Ver  '	;
		DB	03h			;
		CALL	LONGDELAY		;
		CALL	LONGDELAY		;
		JMP	INITCWPROM		;
						;
;-------------------------------------------------------------------------------------------
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVV                                                                                     VVV
;VVV                   INSTRUMENT ROUTINES FOR LOCAL CONTROL                             VVV
;VVV                                                                                     VVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
;
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;///							                                 ///
;///     CONTROLLER WITHOUT EEPROM OR VALID EEPROM DATA                                  ///
;///                                                                                     ///
;///     PLUG-INS - NONE		                                                 ///
;///                                                                                     ///
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;
;
;>>>>>>>>>>>>>> INITIALISE ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						;
						;
INITCWNPROM:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Controller Only '  	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'No EEPROM       '	;
		DB	03h		  	;
		MOV	CONTADD,#80h		; Set default address
		CALL	LONGDELAY		;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Add =   h       '	;
		DB	03h		  	;
						;
		MOV	A,#46h			; Set LCD Write Address
		CALL	SETLCDDISP		; Set data display position
		MOV	A,CONTADD		; Get address
		CALL	LCDVAL			; and display
		MOV	PROMMAP,#00h		;
						;
CNE:		CLR	RXSTRGAV	  	; Reset Received String Flag bit
		CLR	CNTRLFLAG		; Control Data Input
		CLR	STRINGERR		; Clear String Error Flag
		CLR	A       	  	; Reset Bit 0 of DPCON to use main data ptr
		MOV	DPCON,A		  	;
		MOV	DPP,#00h	  	; Set Data Pointer to input buffer
		MOV	DPH,#00h	  	;
		MOV	DPL,#00h	  	;
						;
CNWAITRXD:	JB	RXSTRGAV,CNTRLDAV  	; Loop until string available flag is raised
					        ;
		JB	CNTRLFLAG,CNELOCAL	; Jump if local control data is available
						;
		JMP	CNWAITRXD		; Loop until data in buffer
						;
CNTRLDAV:	CALL	TESTSTRING		; Find end of buffer, address and errors
		JB	STRINGERR,CNE 	 	; If received string is errored restart
						;
		MOV	A,RCVDADD		;
		CJNE	A,#0FEh,CNNORMADD	; Look for BROADCAST address 0FEh
					  	;
		JMP	CNBCADD		  	; Broadcast Address Found
					  	;
CNNORMADD:	CJNE	A,#80h,CNE 	 	; Compare to controller address and
					  	; loop if address does not match
						;
		CALL	GETFUNCTION		; Get CMDBASE and CMDCODE & Display on LCD
		JB	STRINGERR,CNE		; If errored commands found loop
						;
		JMP	CNECCDEC		; Jump to decode command
						;
;
;-------------------------------------------------------------------------------------------
; Respond to local Control Inputs
;-------------------------------------------------------------------------------------------
CNELOCAL:	JMP	CNWAITRXD		; *** Routine to be added ***
						;
;
;>>>>>>>>>>> ROUTINE TO DECODE COMMAND TO BE EXECUTED <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
CNECCDEC:	MOV	A,CODEBASE	  	; Get Codebase in A
		CJNE	A,#00h,CNTRYCB01    	; If Commandbase is not 00h jump
  						;
		JMP	CNCB00		  	; Code Base = 00 Which is SB Core
					  	;
CNTRYCB01:	CJNE	A,#01h,CNTRYCB02    	; If Commandbase is not 01h jump
 					  	;
		JMP	CNCB01		  	; Code Base = 01 Which is SB Utilities
					  	;
CNTRYCB02:	CJNE	A,#02h,CNTRYCB03	; If Commandbase is not 02h jump
					  	;
		JMP	CNCB02		  	; Code Base = 02 Which is SB Analogue
					  	;
CNTRYCB03:	ANL	CONTSTATHI,#00h		; Set status Word for invalid command
		ANL	CONTSTATLO,#24h		;
		CALL	SENDHEAD	  	; Send STX, CONTADD
					  	; CODEBASE, CMDCODE and CONTSTAT
					  	;
		CALL	SENDCRC		  	; Send CRC and EOT string
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'            ' 	        ;
		DB	03h		  	;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Invalid Cmd     '      ;
		DB	03h		  	;
		JMP	CNE			;
						;
;
;>>>>>>>>>>> STARBASE CORE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
CNCB00:		MOV	A,CMDCODE	  	;
		CJNE	A,#00h,CNCORE0001 	;
					  	;
		CALL	PING			;
		JMP	INITPROG	   	; Controller CB = 00 CC = 00
					  	;
CNCORE0001:	CJNE	A,#01h,CNCORE0002  	;
					  	;
		CALL	PING	  		; Controller CB = 00 CC = 01
		JMP	CNE			; Call Ping and loop
					  	;
CNCORE0002:	CJNE	A,#02h,CNCORE0003  	;
					  	;
		JMP	CNCORE0005		; Controller CB = 00 CC = 02
						; Invalid Command
					  	;
CNCORE0003:	CJNE	A,#03h,CNCORE0004	;
						;
		JMP	CNCORE0005		; Controller CB = 00 CC = 03
						; Invalid Command
					  	;
CNCORE0004:	CJNE	A,#04h,CNCORE0005  	;
					  	;
		JMP	CNCORE0005		; Controller CB = 00 CC = 04
						; Invalid Command
						;
CNCORE0005:					; Controller CB = 00 CC > 04
		ANL	CONTSTATHI,#00h		; Set status Word for invalid command
		ANL	CONTSTATLO,#24h		;
		CALL	SENDHEAD	  	; Send STX, CONTADD
					  	; CODEBASE, CMDCODE and CONTSTAT
					  	;
		CALL	SENDCRC		  	; Send CRC and EOT string
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Invalid Cmd     '      ;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'            '          ;
		DB	03h		  	;
		JMP	CNE			;
;
;>>>>>>>>>>> STARBASE UTILITIES <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
CNCB01:		MOV	A,CMDCODE	  	; Get Commandcode
		CJNE	A,#00h,CNUTIL0001  	; Test for 00
						;
		CALL	GETRTCDATE	  	; Controller CB = 01 CC = 00
		JMP	CNE			;
			  			;
CNUTIL0001:	CJNE	A,#01h,CNUTIL0002  	;
					  	;
		CALL	SETRTCDATE	  	; Controller CB = 01 CC = 01
		JMP	CNE			;
					  	;
CNUTIL0002:	CJNE	A,#02h,CNUTIL0003  	;
					  	;
		CALL	GETRTCTIME	  	; Controller CB = 01 CC = 02
		JMP	CNE			;
			  			;
CNUTIL0003:	CJNE	A,#03h,CNUTIL0004  	;
					  	;
		CALL	SETRTCTIME	  	; Controller CB = 01 CC = 03
		JMP	CNE		  	;
						;
CNUTIL0004:	CJNE	A,#04h,CNUTIL0005  	;
					  	;
		CALL	GETCPUTEMP	  	; Controller CB = 01 CC = 04
		JMP	CNE 		 	;
						;
CNUTIL0005:	CJNE	A,#05h,CNUTIL0006	; >> GET SERIAL NUMBER <<
						;
		CALL	GETSERIALNUM		; Controller CB = 00 CC = 05
		JMP	CNTRLWITHPROM	  	;
						;
CNUTIL0006:					; Controller CB = 00 CC > 05
		ANL	CONTSTATHI,#00h		; Set status Word for invalid command
		ANL	CONTSTATLO,#24h		;
		CALL	SENDHEAD	  	; Send STX, CONTADD
					  	; CODEBASE, CMDCODE and CONTSTAT
					  	;
		CALL	SENDCRC		  	; Send CRC and EOT string
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'                ' 	;
		DB	03h		  	;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Invalid Cmd'	        ;
		DB	03h		  	;
		JMP	CNE			;
;
;>>>>>>>>>>> STARBASE ANALOGUE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
CNCB02:		MOV	A,CMDCODE	  	; Get Commandcode
		CJNE	A,#00h,CNANALOG0001  	; Test for 00
						;
		CALL	GETVALA2D	  	; Controller CB = 02 CC = 00
		JMP	CNE			;
			  			;
CNANALOG0001:	CJNE	A,#01h,CNANALOG0002  	;
					  	;
		CALL	GETVALD2A	  	; Controller CB = 02 CC = 01
		JMP	CNE			;
					  	;
CNANALOG0002:	CJNE	A,#02h,CNANALOG0003  	;
					  	;
		CALL	SETVALD2A	  	; Controller CB = 02 CC = 02
		JMP	CNE			;
			  			;
CNANALOG0003:					; Controller CB = 00 CC > 02
		ANL	CONTSTATHI,#00h		; Set status Word for invalid command
		ANL	CONTSTATLO,#24h		;
		CALL	SENDHEAD	  	; Send STX, CONTADD
					  	; CODEBASE, CMDCODE and CONTSTAT
					  	;
		CALL	SENDCRC		  	; Send CRC and EOT string
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Invalid Command ' 	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'            '	        ;
		DB	03h		  	;
		JMP	CNE			;
;
;>>>>>>>>>>> STARBASE BROADCAST <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;						;
CNBCADD:	CALL	DISCOVER		; >> DISCOVER <<
		JMP	CNE			;
;
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;///							                                 ///
;///     CONTROLLER ONLY                                                                 ///
;///                                                                                     ///
;///     PLUG-INS - NONE                                                                 ///
;///                                                                                     ///
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;
;
;>>>>>>>>>>>>>> INITIALISE ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						;
INITCWPROM:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'No Valid module'   	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Connected      '	;
		DB	03h		  	;
		CALL	LONGDELAY		;
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Cntrl with Prom '   	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Add =   h       '	;
		DB	03h		  	;
						;
		MOV	A,#46h			; Set LCD Write Address
		CALL	SETLCDDISP		; Set data display position
		MOV	A,CONTADD		; Get address
		CALL	LCDVAL			; and display
						;
		MOV	PROMMAP,#01h		; Calculate Total size of Config Blocks
		CALL	CALCMAXBLOCK		;
						;
;>>>>>>>>>>> RTOS ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						;
CNTRLWITHPROM:	CLR	RXSTRGAV	  	; Reset Received String Flag bit
		CLR	CNTRLFLAG		; Control Data Input
		CLR	STRINGERR		; Clear String Error Flag
		CLR	TIMERFLAG		;
		CLR	A       	  	; Reset Bit 0 of DPCON to use main data ptr
		MOV	DPCON,A		  	;
		MOV	DPP,#00h	  	; Set Data Pointer to input buffer
		MOV	DPH,#00h	  	;
		MOV	DPL,#00h	  	;
						;
CWWAITRXD:	JNB	LOGEN,CWTSTRXDAV	; Jump if logging not enabled
						;
CWTSTRXDAV:	JB	RXSTRGAV,CWTRLDAV  	; Jump if data available flag is raised
						;
		JB	CNTRLFLAG,CWLOCAL	; Jump if local control data is available
						;
		JMP	CWWAITRXD		; Loop until interupt data available
						;
CWTRLDAV:	CALL	TESTSTRING		; Find end of buffer, address and errors
		JB	STRINGERR,CNTRLWITHPROM	; If received string is errored restart
						;
		MOV	A,RCVDADD		;
		CJNE	A,#0FEh,CWNORMADD	; Look for BROADCAST address 0FEh
					  	;
		JMP	CWBCADD			; Broadcast Address Found
					  	;
CWNORMADD:	CJNE	A,CONTADD,CNTRLWITHPROM	; Compare to controller address and
					  	; loop if address does not match
						;
		CALL	GETFUNCTION		; Get CMDBASE and CMDCODE & Display on LCD
		JB	STRINGERR,CNTRLWITHPROM	; If errored commands found loop
						;
		JMP	CWCCDEC			; Jump to decode command
						;
;
;-------------------------------------------------------------------------------------------
; Respond to local Control Inputs
;-------------------------------------------------------------------------------------------
CWLOCAL:	JMP	CNWAITRXD		; *** Routine to be added ***
						;
;
;>>>>>>>>>>> ROUTINE TO DECODE COMMAND TO BE EXECUTED <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
CWCCDEC:	MOV	A,CODEBASE	  	; Get Codebase in A
		CJNE	A,#00h,CWTRYCB01    	; If Commandbase is not 00h jump
  						;
		JMP	CWCB00		  	; Code Base = 00 Which is SB Core
					  	;
CWTRYCB01:	CJNE	A,#01h,CWTRYCB02    	; If Commandbase is not 01h jump
 					  	;
		JMP	CWCB01		  	; Code Base = 01 Which is SB Utilities
					  	;
CWTRYCB02:	CJNE	A,#02h,CWINVALID	; If Commandbase is not 02h jump
					  	;
		JMP	CWCB02		  	; Code Base = 02 Which is SB Analogue
					  	;
CWINVALID:	ANL	CONTSTATHI,#00h		; Set status Word for invalid command
		ANL	CONTSTATLO,#24h		;
		CALL	SENDHEAD	  	; Send STX, CONTADD
					  	; CODEBASE, CMDCODE and CONTSTAT
					  	;
		CALL	SENDCRC		  	; Send CRC and EOT string
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'            ' 	        ;
		DB	03h		  	;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Invalid Cmd     '      ;
		DB	03h		  	;
		JMP	CNTRLWITHPROM		;
						;
;
;>>>>>>>>>>> STARBASE CORE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
CWCB00:		MOV	A,CMDCODE	  	;
		CJNE	A,#00h,CWCORE0001 	; >> RESET <<
					  	;
		CALL	PING			;
		JMP	INITPROG	   	; Controller CB = 00 CC = 00
					  	;
CWCORE0001:	CJNE	A,#01h,CWCORE0002  	; >> PING <<
					  	;
		CALL	PING	  		; Controller CB = 00 CC = 01
		JMP	CNTRLWITHPROM		; Call Ping and loop
					  	;
CWCORE0002:	CJNE	A,#02h,CWCORE0003  	; >> GETCONFIG <<
					  	;
		JMP	CWINVALID		; Controller CB = 00 CC = 02
						; Invalid Command SB Virtual
						;
CWCORE0003:	CJNE	A,#03h,CWCORE0004	; >> GET MAX BLOCK <<
						;
		CALL	GETCNFGMAX		; Controller CB = 00 CC = 03
		JMP	CNTRLWITHPROM		; Call to find size of XML
						;
CWCORE0004:	CJNE	A,#04h,CWCORE0005  	; >> GET BLOCK <<
					  	;
		CALL	GETCNFGBLOCK		; Controller CB = 00 CC = 04
		JMP	CNTRLWITHPROM		; Call to get XML block and send
						;
CWCORE0005:	JMP	CWINVALID		; Invalid command - out of range
;
;>>>>>>>>>>> STARBASE UTILITIES <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
CWCB01:		MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,CWUTIL0001  	; >> GET DATE <<
						;
		CALL	GETRTCDATE	  	; Controller CB = 01 CC = 00
		JMP	CNTRLWITHPROM		;
			  			;
CWUTIL0001:	CJNE	A,#01h,CWUTIL0002  	; >> SET DATE <<
					  	;
		CALL	SETRTCDATE	  	; Controller CB = 01 CC = 01
		JMP	CNTRLWITHPROM		;
					  	;
CWUTIL0002:	CJNE	A,#02h,CWUTIL0003  	; >> GET TIME <<
					  	;
		CALL	GETRTCTIME	  	; Controller CB = 01 CC = 02
		JMP	CNTRLWITHPROM		;
			  			;
CWUTIL0003:	CJNE	A,#03h,CWUTIL0004  	; >> SET TIME <<
					  	;
		CALL	SETRTCTIME	  	; Controller CB = 01 CC = 03
		JMP	CNTRLWITHPROM	  	;
						;
CWUTIL0004:	CJNE	A,#04h,CWUTIL0005  	; >> GET CPU TEMPERATURE <<
					  	;
		CALL	GETCPUTEMP	  	; Controller CB = 01 CC = 04
		JMP	CNTRLWITHPROM	  	;
						;
CWUTIL0005: 	CJNE	A,#05h,CWUTIL0006	; >> GET EEPROM <<
						;
		CALL	GETEEPROM		; Controller CB = 00 CC = 05
		JMP	CNTRLWITHPROM	  	;
						;
CWUTIL0006:	CJNE	A,#06h,CWUTIL0007	; >> SET EEPROM <<
						;
		CALL	SETEEPROM		; Controller CB = 00 CC = 06
		JMP	CNTRLWITHPROM	  	;
						;
CWUTIL0007:	CJNE	A,#07h,CWUTIL0008	; >> GET SERIAL NUMBER <<
						;
		CALL	GETSERIALNUM		; Controller CB = 00 CC = 07
		JMP	CNTRLWITHPROM	  	;
						;
CWUTIL0008:	JMP	CWINVALID		; Controller CB = 00 CC > 07
						; invalid command
						;
;
;>>>>>>>>>>> STARBASE ANALOGUE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
CWCB02:		MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,CWANALOG0001  	; >> GET A2D <<
						;
		CALL	GETVALA2D	  	; Controller CB = 02 CC = 00
		JMP	CNTRLWITHPROM		;
			  			;
CWANALOG0001:	CJNE	A,#01h,CWANALOG0002  	; >> GET D2A <<
					  	;
		CALL	GETVALD2A	  	; Controller CB = 02 CC = 01
		JMP	CNTRLWITHPROM		;
					  	;
CWANALOG0002:	CJNE	A,#02h,CWANALOG0003  	; >> SET D2A <<
					  	;
		CALL	SETVALD2A	  	; Controller CB = 02 CC = 02
		JMP	CNTRLWITHPROM		;
			  			;
CWANALOG0003:	JMP	CWINVALID		; Controller CB = 00 CC > 02
						; invalid command
						;
						;
;
;>>>>>>>>>>> STARBASE BROADCAST <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
CWBCADD:	CALL	DISCOVER		; >> DISCOVER <<
		JMP	CNTRLWITHPROM		;
						;
;
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;///							                                 ///
;///     INSTRUMENT 01 - VLF RECEIVER - VERSION 01 BAA ORIGINAL DESIGN                   ///
;///                                                                                     ///
;///     PLUG-INS - A2h - VLF BOARD WITH NO CONFIGURABLE ITEMS - EEPROM & TEMP SENSOR    ///
;///                                                                                     ///
;///                                                                                     ///
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;
;	VLF Instrument Module commands
;
;	Command 	Routine		Starbase Name	  Purpose
;
;	CB04 CC00			getTemperature	  Get Magnetometer gain setting
;
;>>>>>>>>>>>>>> INITIALISE ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						;
INITVLF01:	MOV	PROMMAP,#03h		; Calculate Total size of Config Blocks
		CALL	CALCMAXBLOCK		;
						;
;>>>>>>>>>>> RTOS ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						;
VLF01:		CLR	RXSTRGAV	  	; Reset Received String Flag bit
		CLR	CNTRLFLAG		; Control Data Input
		CLR	STRINGERR		; Clear String Error Flag
		CLR	TIMERFLAG		;
		CLR	A       	  	; Reset Bit 0 of DPCON to use main data ptr
		MOV	DPCON,A		  	;
		MOV	DPP,#00h	  	; Set Data Pointer to input buffer
		MOV	DPH,#00h	  	;
		MOV	DPL,#00h	  	;
						;
VLF01WAITRXD:	JNB	LOGEN,VLF01TSTRXDAV	; Jump if logging not enabled
						;
		JB	TIMERFLAG,VLF01LOGDATA	; Jump if logging sample flag set
						;
VLF01TSTRXDAV:	JB	RXSTRGAV,VLF01TRLDAV  	; Jump if data available flag is raised
						;
		JB	CNTRLFLAG,VLF01LOCAL	; Jump if local control data is available
						;
		JMP	VLF01WAITRXD		; Loop until interupt data available
						;
VLF01TRLDAV:	CALL	TESTSTRING		; Find end of buffer, address and errors
		JB	STRINGERR,VLF01		; If received string is errored restart
						;
		MOV	A,RCVDADD		;
		CJNE	A,#0FEh,VLF01NORMADD	; Look for BROADCAST address 0FEh
					  	;
		JMP	VLF01BCADD		; Broadcast Address Found
					  	;
VLF01NORMADD:	CJNE	A,CONTADD,VLF01		; Compare to controller address and
					  	; loop if address does not match
						;
		CALL	GETFUNCTION		; Get CMDBASE and CMDCODE & Display on LCD
		JB	STRINGERR,VLF01		; If errored commands found loop
						;
		JMP	VLF01CCDEC		; Jump to decode command
						;
;
;-------------------------------------------------------------------------------------------
; Respond to local Control Inputs
;-------------------------------------------------------------------------------------------
VLF01LOCAL:	JMP	VLF01WAITRXD		; *** Routine to be added ***
						;
;
;-------------------------------------------------------------------------------------------
; Logging Routine
;-------------------------------------------------------------------------------------------
;
VLF01LOGDATA:	MOV	DPP,LOGPTRPG		; Recover data pointer registers
		MOV	DPH,LOGPTRHI		;
		MOV	DPL,LOGPTRLO 		;
		JNB	NEWBLOCK,VLF01SAMWR	; Test if new logging block required
					  	;
		CLR	NEWBLOCK		; Reset new block flag
		CALL	WRLOGHEAD		; Write header to XRAM
						;
VLF01SAMWR:	MOV	A,#00h			; Select ADC 0
		CALL	GETADCVAL		; Read data into ADCDATAH and ADCDATAL
		MOV	A,ADCDATAH		; Get ADC Hi Byte
		MOVX	@DPTR,A			; Save ADC Hi Value
		INC	DPTR			;
		MOV	A,ADCDATAL		; Get ADC Hi Byte
		MOVX	@DPTR,A			; Save ADC Lo Value
		INC	DPTR			;
						;
		INC	SAMCOUNT	  	; Increment the sample counter
		MOV	A,SAMCOUNT	  	;
		CJNE	A,#78h,VLF01ENDLOG	; If sample Count < 120 Jump to end
						;
		MOV	SAMCOUNT,#00h		; Sample = 61 reset sample counter
		MOV	A,BLOCKLO		; Increment Block Counter
		CLR	C			;
		ADD	A,#01h		  	;
		MOV	BLOCKLO,A		;
		JNC	VLF01BCMAXTEST	  	; If no carry jump
					  	;
		INC	BLOCKHI		  	;
						;
VLF01BCMAXTEST:	SETB	NEWBLOCK	  	; Mark new block header required
		MOV	A,BLOCKHI		; Test for end of Logging RAM
		CJNE	A,#07h,VLF01ENDLOG	; Max Block Size is 07FBh
					  	;
		MOV	A,BLOCKLO		;
		CJNE	A,#0FCh,VLF01ENDLOG	;
					  	;
		CLR	LOGEN		  	; End of RAM found, Clear Logging Flag
		MOV	CONTSTATHI,#00h	  	; Reset Status Flag
		MOV	CONTSTATLO,#00h		;
		MOV	DPP,00h			; Write Max Block size to all block headers
		MOV	DPH,18h			; Set up Data Pointer
		MOV	DPL,0Bh			;
VLF01MAXBKLOOP:	MOV	A,#07Fh			; Write 07FBh to block
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
		MOV	A,0FBh			;
		MOVX	@DPTR,A			;
		MOV	DPL,#0Bh	  	; Restore pointer for next block
					  	;
		MOV	A,#01h		  	; Increment block pointer
		CLR C				;
		ADD	A,DPH			;
		MOV	DPH,A  			;
		JNC	VLF01WRENDTEST	  	; and test for overrun to DPP
					  	;
		MOV	DPH,A		  	; If overrun Save DPH
		INC	DPP		  	; Increment DPP
VLF01WRENDTEST:	MOV	A,DPP		  	; Look for last block
		CJNE	A,#0Fh,VLF01MAXBKLOOP 	;
					  	;
		MOV	A,DPH		  	;
		CJNE	A,#0FFh,VLF01MAXBKLOOP	; Continue until all written
					  	;
VLF01ENDLOG:	MOV	LOGPTRPG,DPP 		; Save Pointers
		MOV	LOGPTRHI,DPH		;
		MOV	LOGPTRLO,DPL		;
					  	;
		JMP	VLF01			;
						;
;
;>>>>>>>>>>> ROUTINE TO DECODE COMMAND TO BE EXECUTED <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
VLF01CCDEC:	MOV	A,CODEBASE	  	; Get Codebase in A
		CJNE	A,#00h,VL01TRYCB01    	; If Commandbase is not 00h jump
  						;
		JMP	VL01CB00	  	; Code Base = 00 Which is SB Core
					  	;
VL01TRYCB01:	CJNE	A,#01h,VL01TRYCB02    	; If Commandbase is not 01h jump
 					  	;
		JMP	VL01CB01	  	; Code Base = 01 Which is SB Utilities
					  	;
VL01TRYCB02:	CJNE	A,#02h,VL01TRYCB03    	; If Commandbase is not 02h jump
 					  	;
		JMP	VL01CB02	  	; Code Base = 02 Which is SB Analogue
					  	;
VL01TRYCB03:	CJNE	A,#03h,VL01TRYCB04	; If Commandbase is not 03h jump
					  	;
		JMP	VL01CB03	  	; Code Base = 03 Which is SB Capture
					  	;
VL01TRYCB04:	CJNE	A,#04h,VL01INVALID	; If Commandbase is not 04h jump
						;
		JMP	VL01CB04		; Code Base = 04 which is VLF Rx Functions
						;
VL01INVALID:	ANL	CONTSTATHI,#80h		; Set status Word for invalid command
		ANL	CONTSTATLO,#24h		;
		CALL	SENDHEAD	  	; Send STX, CONTADD
					  	; CODEBASE, CMDCODE and CONTSTAT
					  	;
		CALL	SENDCRC		  	; Send CRC and EOT string
		JB	LCDLOCAL,VLF01INVCOM	;
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Invalid Cmd     ' 	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'            '	        ;
		DB	03h		  	;
VLF01INVCOM:	JMP	VLF01			;
						;
;
;>>>>>>>>>>> STARBASE CORE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
VL01CB00:	MOV	A,CMDCODE	  	;
		CJNE	A,#00h,VL01CORE0001 	; >> RESET <<
					  	;
		CALL	PING			; Send a response before reset
		JMP	INITPROG	   	; Controller CB = 00 CC = 00
					  	;
VL01CORE0001:	CJNE	A,#01h,VL01CORE0002  	; >> PING <<
					  	;
		CALL	PING	  		; Controller CB = 00 CC = 01
		JMP	VLF01			; Call Ping and loop
					  	;
VL01CORE0002:	CJNE	A,#02h,VL01CORE0003  	; >> GETCONFIG <<
					  	;
		JMP	VL01INVALID		; Controller CB = 00 CC = 02
						; Invalid Command SB Virtual
						;
VL01CORE0003:	CJNE	A,#03h,VL01CORE0004	; >> GET MAX BLOCK <<
						;
		CALL	GETCNFGMAX		; Controller CB = 00 CC = 03
		JMP	VLF01			; Call to find size of XML
						;
VL01CORE0004:	CJNE	A,#04h,VL01CORE0005  	; >> GET BLOCK <<
					  	;
		CALL	GETCNFGBLOCK		; Controller CB = 00 CC = 04
		JMP	VLF01			; Call to get XML block and send
						;
VL01CORE0005:	JMP	VL01INVALID		; Invalid command - out of range
;
;>>>>>>>>>>> STARBASE UTILITIES <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
VL01CB01:	MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,VL01UTIL0001  	; >> GET DATE <<
						;
		CALL	GETRTCDATE	  	; Controller CB = 01 CC = 00
		JMP	VLF01			;
			  			;
VL01UTIL0001:	CJNE	A,#01h,VL01UTIL0002  	; >> SET DATE <<
					  	;
		CALL	SETRTCDATE	  	; Controller CB = 01 CC = 01
		JMP	VLF01			;
					  	;
VL01UTIL0002:	CJNE	A,#02h,VL01UTIL0003  	; >> GET TIME <<
					  	;
		CALL	GETRTCTIME	  	; Controller CB = 01 CC = 02
		JMP	VLF01			;
			  			;
VL01UTIL0003:	CJNE	A,#03h,VL01UTIL0004  	; >> SET TIME <<
					  	;
		CALL	SETRTCTIME	  	; Controller CB = 01 CC = 03
		JMP	VLF01	  		;
						;
VL01UTIL0004:	CJNE	A,#04h,VL01UTIL0005  	; >> GET CPU TEMPERATURE <<
					  	;
		CALL	GETCPUTEMP	  	; Controller CB = 01 CC = 04
		JMP	VLF01	  		;
						;
VL01UTIL0005: 	CJNE	A,#05h,VL01UTIL0006	; >> GET EEPROM <<
						;
		CALL	GETEEPROM		; Controller CB = 00 CC = 05
		JMP	VLF01		  	;
						;
VL01UTIL0006:	CJNE	A,#06h,VL01UTIL0007	; >> SET EEPROM <<
						;
		CALL	SETEEPROM		; Controller CB = 00 CC = 06
		JMP	VLF01		  	;
						;
VL01UTIL0007:	CJNE	A,#07h,VL01UTIL0008	; >> GET Serial Number <<
						;
		CALL	GETSERIALNUM		; Controller CB = 01 CC = 07
		JMP	VLF01		  	;
						;
VL01UTIL0008:	JMP	VL01INVALID		; Controller CB = 00 CC > 07
						; invalid command
						;
;
;>>>>>>>>>>> STARBASE ANALOGUE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
VL01CB02:	MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,VL01ANALOG0001  	; >> GET A2D <<
						;
		CALL	GETVALA2D	  	; Controller CB = 02 CC = 00
		JMP	VLF01			;
			  			;
VL01ANALOG0001:	CJNE	A,#01h,VL01ANALOG0002  	; >> GET D2A <<
					  	;
		CALL	GETVALD2A	  	; Controller CB = 02 CC = 01
		JMP	VLF01			;
					  	;
VL01ANALOG0002:	CJNE	A,#02h,VL01ANALOG0003  	; >> SET D2A <<
					  	;
		CALL	SETVALD2A	  	; Controller CB = 02 CC = 02
		JMP	VLF01			;
			  			;
VL01ANALOG0003:	JMP	VL01INVALID		; Controller CB = 00 CC > 02
						; invalid command
						;
;
;>>>>>>>>>>> STARBASE DATA CAPTURE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
VL01CB03:	MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,VF01LOG0001  	; >> getSpace <<
						;
		CALL	GETSPACE	  	; Controller CB = 03 CC = 00
		JMP	VLF01			;
			  			;
VF01LOG0001:	CJNE	A,#01h,VF01LOG0002  	; >> getData <<
					  	;
		JMP	VF01LOG0007	  	; Controller CB = 03 CC = 01
					  	;
VF01LOG0002:	CJNE	A,#02h,VF01LOG0003  	; >> getDataBlockCount <<
					  	;
		CALL	GETMAXBLOCK  		; Controller CB = 03 CC = 02
		JMP	VLF01			;
			  			;
VF01LOG0003:	CJNE	A,#03h,VF01LOG0004  	; >> getDataBlock <<
					  	;
		JB	EXISTINGLOG,GDH		; Jump if logging data exists
						;
		CALL	EMPTYBLOCK		; Send empty block
		JMP	VLF01DATAERR		;
						;
GDH:		CALL	GETDATAHEAD	  	; Controller CB = 03 CC = 03
		MOV	A,CONTSTATLO		; Test for errors
		JNZ	VLF01DATAERR		; Do not send data if errors
						;
		CALL	GETVLF01DATA		; Get and output data block
		JMP	VLF01			;
						;
VLF01DATAERR:	JB	LCDLOCAL,NODERRLCD	; Jump if in local mode
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getDataBlock    '      ;
		DB	03h		  	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      ' 		;
		DB	03h		  	;
NODERRLCD:	JMP	VLF01			;
						;
VF01LOG0004:	CJNE	A,#04h,VF01LOG0005  	; >> getRate <<
					  	;
		CALL	GETRATE		  	; Controller CB = 03 CC = 04
		JMP	VLF01			;
						;
VF01LOG0005:	CJNE	A,#05h,VF01LOG0006  	; >> setRate <<
					  	;
		CALL	SETRATE			; Controller CB = 03 CC = 05
		JMP	VLF01			;
						;
VF01LOG0006:	CJNE	A,#06h,VF01LOG0007  	; >> capture <<
					  	;
		CALL	CAPTURE			; Controller CB = 03 CC = 06
		JMP	VLF01			;
						;
VF01LOG0007:	JMP	VL01INVALID		; Controller CB = 03 CC > 06
						; invalid command
						;
;
;>>>>>>>>>>> STARBASE INSTRUMENT FUNCTIONS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
VL01CB04:	MOV	A,CMDCODE		; Get Command Code
						;
		CJNE	A,#00h,VLF01NOFUNC	; >> GET VLF 01 TEMPERATURE <<
						;
		CALL	VLF01GETTEMP		; Instrument CB = 04 CC = 00
		JMP	VLF01			;
						;
VLF01NOFUNC:	JMP	VL01INVALID		; Controller CB = 04 CC > 00
						; invalid command
						;
;
;>>>>>>>>>>> STARBASE BROADCAST <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
VLF01BCADD:	CALL	DISCOVER		; >> DISCOVER <<
		JMP	VLF01			;
						;
;
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;///							                                 ///
;///     INSTRUMENT 01 - VLF RECEIVER - VERSION 02 ASTROMETRICS TUNEABLE DESIGN          ///
;///                                                                                     ///
;///     PLUGINS - A2h - VLF BOARD - DDS SYNTH, GAIN, INPUT SELECT & TEMP SENSOR         ///
;///                                                                                     ///
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;
INITVLF02:	MOV	PROMMAP,#03h		; Calculate Total size of Config Blocks
		CALL	CALCMAXBLOCK		;
						;

VLF02:	JMP	INITPROG			;



;
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;///							                                 ///
;///     INSTRUMENT 02 - MAGNETOMETER - VERSION 01 JOHN COOK ORIGINAL DESIGN             ///
;///                                                                                     ///
;///     PLUGINS - A2h - MAGNETOMETER BOARD - PIC TIME CONSTANTS & GAIN, temperature     ///
;///                                                                                     ///
;///     Magnetometer I2C address = 0010 000x                                            ///
;///     The first byte written to the interface is a pointer byte                       ///
;///     Subsquent read/write bytes set or read data registers                           ///
;///                                                                                     ///
;///     Register  00h = Gain Control	Range 01h to 04h	Read/Write               ///
;///               01h = X Axis High          00h to 03h        Read Only                ///
;///               01h = X Axis Low           00h to FFh        Read Only                ///
;///               01h = Y Axis High          00h to 03h        Read Only                ///
;///               01h = Y Axis Low           00h to FFh        Read Only                ///
;///                                                                                     ///
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;
;   Magnetometer Instrument Module Commands
;
;	Command 	Routine		Starbase Name	  Purpose
;
;	CB04 CC00			getGain	  	  Get Magnetometer gain setting
;	CB04 CC01			setGain()	  Set Magnetometer gain (1-4)
;	CB04 CC02			getXcomponent	  Get X Axis output -512 to +511
;	CB04 CC03			getYcomponent	  Get Y Axis output -512 to +511
;	CB04 CC04			getTemperature	  Get Instrument Temperature
;
;>>>>>>>>>>> INITIALISE ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						;
INITMAG01:	MOV	PROMMAP,#03h		; Calculate Total size of Config Blocks
		CALL	CALCMAXBLOCK		;
						;
;>>>>>>>>>>> RTOS ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						;
MAG01:		CLR	RXSTRGAV	  	; Reset Received String Flag bit
		CLR	CNTRLFLAG		; Control Data Input
		CLR	STRINGERR		; Clear String Error Flag
		CLR	TIMERFLAG		;
		CLR	A       	  	; Reset Bit 0 of DPCON to use main data ptr
		MOV	DPCON,A		  	;
		MOV	DPP,#00h	  	; Set Data Pointer to input buffer
		MOV	DPH,#00h	  	;
		MOV	DPL,#00h	  	;
						;
MG01WAITRXD:	JNB	LOGEN,TESTRXDAV		; Jump if logging not enabled
						;
		JB	TIMERFLAG,LOGDATA	; Jump if logging sample flag set
						;
TESTRXDAV:	JB	RXSTRGAV,MG01TRLDAV  	; Jump if data available flag is raised
						;
		JB	CNTRLFLAG,GETLOCAL	; Jump if local control data is available
						;
		JMP	MG01WAITRXD		; Loop until interupt data available
						;
MG01TRLDAV:	CALL	TESTSTRING		; Find end of buffer, address and errors
		JB	STRINGERR,MAG01		; If received string is errored restart
						;
		MOV	A,RCVDADD		;
		CJNE	A,#0FEh,MG01NORMADD	; Look for BROADCAST address 0FEh
					  	;
		JMP	MG01BCADD		; Broadcast Address Found
					  	;
MG01NORMADD:	CJNE	A,CONTADD,MAG01		; Compare to controller address and
					  	; loop if address does not match
						;
		CALL	GETFUNCTION		; Get CMDBASE and CMDCODE & Display on LCD
		JB	STRINGERR,MAG01		; If errored commands found loop
						;
		JMP	MAGCCDEC		; Jump to decode command
						;
;
;-------------------------------------------------------------------------------------------
; Respond to local Control Inputs
;-------------------------------------------------------------------------------------------
GETLOCAL:	JMP	MG01WAITRXD		; *** Routine to be added ***
						;
;
;-------------------------------------------------------------------------------------------
; Logging Routine
;-------------------------------------------------------------------------------------------
;
LOGDATA:	MOV	DPP,LOGPTRPG		; Recover data pointer registers
		MOV	DPH,LOGPTRHI		;
		MOV	DPL,LOGPTRLO 		;
		JNB	NEWBLOCK,SAMWR		; Test if new logging block required
					  	;
		CLR	NEWBLOCK		; Reset new block flag
		CALL	WRLOGHEAD		; Write header to XRAM
						;
SAMWR:		CLR	LASTBYTE		; X Axis logging
		CLR	NOACK	  		; Reset I2C error flag
		CALL	STARTBIT		;
		MOV	A,#20h			; Write magnetometer address 20h
		CALL	SENDBYTE		;
		MOV	A,#01h			; Select X Axis Hi register
		CALL	SENDBYTE		;
		CALL	STARTBIT	  	;
		MOV	A,#21h		  	; Write magnetometer address + Read
		CALL	SENDBYTE	  	;
		CALL	RCVBYTE			; Get X Hi Value
		MOV	A,I2CRXBUF		;
		MOVX	@DPTR,A			; Save X Hi Value
		INC	DPTR			;
		CALL	RCVBYTE			; Get X Lo Value
		MOV	A,I2CRXBUF		;
		MOVX	@DPTR,A			; Save X Lo Value
		INC	DPTR			;
		CALL	RCVBYTE			; Get Y Hi Value
		MOV	A,I2CRXBUF		;
		MOVX	@DPTR,A			; Save Y Hi Value
		INC	DPTR			;
		SETB	LASTBYTE		; Signal Last BYte Read
		CALL	RCVBYTE			; Get Y Lo Value
		MOV	A,I2CRXBUF		;
		MOVX	@DPTR,A			; Save Y Lo Value
		INC	DPTR			;
		CALL	STOPBIT			;
					  	;
		INC	SAMCOUNT	  	; Increment the sample counter
		MOV	A,SAMCOUNT	  	;
		CJNE	A,#3Ch,ENDMAGLOG	; If sample Count < 60 Jump to end
						;
		MOV	SAMCOUNT,#00h		; Sample = 61 reset sample counter
		MOV	A,BLOCKLO		; Increment Block Counter
		CLR	C			;
		ADD	A,#01h		  	;
		MOV	BLOCKLO,A		;
		JNC	BCMAXTEST	  	; If no carry jump
					  	;
		INC	BLOCKHI		  	;
						;
BCMAXTEST:	SETB	NEWBLOCK	  	; Mark new block header required
		MOV	A,BLOCKHI		; Test for end of Logging RAM
		CJNE	A,#07h,ENDMAGLOG	; Max Block Size is 07FBh
					  	;
		MOV	A,BLOCKLO		;
		CJNE	A,#0FCh,ENDMAGLOG	;
					  	;
		CLR	LOGEN		  	; End of RAM found, Clear Logging Flag
		MOV	CONTSTATHI,#00h	  	; Reset Status Flag
		MOV	CONTSTATLO,#00h		;
		MOV	DPP,00h			; Write Max Block size to all block headers
		MOV	DPH,18h			; Set up Data Pointer
		MOV	DPL,0Bh			;
MAXBKLOOP:	MOV	A,#07Fh			; Write 07FBh to block
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
		MOV	A,0FBh			;
		MOVX	@DPTR,A			;
		MOV	DPL,#0Bh	  	; Restore pointer for next block
					  	;
		MOV	A,#01h		  	; Increment block pointer
		CLR 	C			;
		ADD	A,DPH			;
		MOV	DPH,A  			;
		JNC	WRENDTEST	  	; and test for overrun to DPP
					  	;
		MOV	DPH,A		  	; If overrun Save DPH
		INC	DPP		  	; Increment DPP
WRENDTEST:	MOV	A,DPP		  	; Look for last block
		CJNE	A,#0Fh,MAXBKLOOP 	;
					  	;
		MOV	A,DPH		  	;
		CJNE	A,#0FFh,MAXBKLOOP	; Continue until all written
					  	;
ENDMAGLOG:	MOV	LOGPTRPG,DPP 		; Save Pointers
		MOV	LOGPTRHI,DPH		;
		MOV	LOGPTRLO,DPL		;
					  	;
		JMP	MAG01			;
						;
;
;>>>>>>>>>>> ROUTINE TO DECODE COMMAND TO BE EXECUTED <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
MAGCCDEC:	MOV	A,CODEBASE	  	; Get Codebase in A
		CJNE	A,#00h,MG01TRYCB01    	; If Commandbase is not 00h jump
  						;
		JMP	MG01CB00	  	; Code Base = 00 Which is SB Core
					  	;
MG01TRYCB01:	CJNE	A,#01h,MG01TRYCB02    	; If Commandbase is not 01h jump
 					  	;
		JMP	MG01CB01	  	; Code Base = 01 Which is SB Utilities
					  	;
MG01TRYCB02:	CJNE	A,#02h,MG01TRYCB03	; If Commandbase is not 02h jump
					  	;
		JMP	MG01CB02	  	; Code Base = 02 Which is SB Analogue
						;
MG01TRYCB03:	CJNE	A,#03h,MG01TRYCB04	; If Commandbase is not 03h jump
					  	;
		JMP	MG01CB03	  	; Code Base = 03 Which is SB Logging
						;
MG01TRYCB04:	CJNE	A,#04h,MG01INVALID	; If Commandbase is not 04h jump
					  	;
		JMP	MG01CB04	  	; Code Base = 04 Which is Magnetometer Functions
					  	;
MG01INVALID:	ANL	CONTSTATHI,#80h		; Set status Word for invalid command
		ORL	CONTSTATLO,#24h		;
		CALL	SENDHEAD	  	; Send STX, CONTADD
					  	; CODEBASE, CMDCODE and CONTSTAT
					  	;
		CALL	SENDCRC		  	; Send CRC and EOT string
		JB	LCDLOCAL,MAGINVCOM	;
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Invalid Cmd     '      ;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'            '      	;
		DB	03h		  	;
MAGINVCOM:	JMP	MAG01			;
						;
;
;>>>>>>>>>>> STARBASE CORE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
MG01CB00:	MOV	A,CMDCODE	  	;
		CJNE	A,#00h,MG01CORE0001 	; >> RESET <<
					  	;
		CALL	PING			; Send a response before reset
		JMP	INITPROG	   	; Controller CB = 00 CC = 00
					  	;
MG01CORE0001:	CJNE	A,#01h,MG01CORE0002  	; >> PING <<
					  	;
		CALL	PING	  		; Controller CB = 00 CC = 01
		JMP	MAG01			; Call Ping and loop
					  	;
MG01CORE0002:	CJNE	A,#02h,MG01CORE0003  	; >> GETCONFIG <<
					  	;
		JMP	MG01INVALID		; Controller CB = 00 CC = 02
						; Invalid Command SB Virtual
						;
MG01CORE0003:	CJNE	A,#03h,MG01CORE0004	; >> GET MAX BLOCK <<
						;
		CALL	GETCNFGMAX		; Controller CB = 00 CC = 03
		JMP	MAG01			; Call to find size of XML
						;
MG01CORE0004:	CJNE	A,#04h,MG01CORE0005  	; >> GET BLOCK <<
					  	;
		CALL	GETCNFGBLOCK		; Controller CB = 00 CC = 04
		JMP	MAG01			; Call to get XML block and send
						;
MG01CORE0005:	JMP	MG01INVALID		; Invalid command - out of range
;
;>>>>>>>>>>> STARBASE UTILITIES <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
MG01CB01:	MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,MG01UTIL0001  	; >> GET DATE <<
						;
		CALL	GETRTCDATE	  	; Controller CB = 01 CC = 00
		JMP	MAG01			;
			  			;
MG01UTIL0001:	CJNE	A,#01h,MG01UTIL0002  	; >> SET DATE <<
					  	;
		CALL	SETRTCDATE	  	; Controller CB = 01 CC = 01
		JMP	MAG01			;
					  	;
MG01UTIL0002:	CJNE	A,#02h,MG01UTIL0003  	; >> GET TIME <<
					  	;
		CALL	GETRTCTIME	  	; Controller CB = 01 CC = 02
		JMP	MAG01			;
			  			;
MG01UTIL0003:	CJNE	A,#03h,MG01UTIL0004  	; >> SET TIME <<
					  	;
		CALL	SETRTCTIME	  	; Controller CB = 01 CC = 03
		JMP	MAG01	  		;
						;
MG01UTIL0004:	CJNE	A,#04h,MG01UTIL0005  	; >> GET CPU TEMPERATURE <<
					  	;
		CALL	GETCPUTEMP	  	; Controller CB = 01 CC = 04
		JMP	MAG01	  		;
						;
MG01UTIL0005: 	CJNE	A,#05h,MG01UTIL0006	; >> GET EEPROM <<
						;
		CALL	GETEEPROM		; Controller CB = 01 CC = 05
		JMP	MAG01		  	;
						;
MG01UTIL0006:	CJNE	A,#06h,MG01UTIL0007	; >> SET EEPROM <<
						;
		CALL	SETEEPROM		; Controller CB = 01 CC = 06
		JMP	MAG01		  	;
						;
MG01UTIL0007:	CJNE	A,#07h,MG01UTIL0008	; >> SET EEPROM <<
						;
		CALL	GETSERIALNUM		; Controller CB = 01 CC = 07
		JMP	MAG01		  	;
						;
MG01UTIL0008:	JMP	MG01INVALID		; Controller CB = 01 CC > 07
						; invalid command
						;
;
;>>>>>>>>>>> STARBASE ANALOGUE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
MG01CB02:	MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,MG01ANALOG0001  	; >> GET A2D <<
						;
		CALL	GETVALA2D	  	; Controller CB = 02 CC = 00
		JMP	MAG01			;
			  			;
MG01ANALOG0001:	CJNE	A,#01h,MG01ANALOG0002  	; >> GET D2A <<
					  	;
		CALL	GETVALD2A	  	; Controller CB = 02 CC = 01
		JMP	MAG01			;
					  	;
MG01ANALOG0002:	CJNE	A,#02h,MG01ANALOG0003  	; >> SET D2A <<
					  	;
		CALL	SETVALD2A	  	; Controller CB = 02 CC = 02
		JMP	MAG01			;
			  			;
MG01ANALOG0003:	JMP	MG01INVALID		; Controller CB = 02 CC > 02
						; invalid command
						;
;
;>>>>>>>>>>> STARBASE DATA CAPTURE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
MG01CB03:	MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,MG01LOG0001  	; >> getSpace <<
						;
		CALL	GETSPACE	  	; Controller CB = 03 CC = 00
		JMP	MAG01			;
			  			;
MG01LOG0001:	CJNE	A,#01h,MG01LOG0002  	; >> getData <<
					  	;
		JMP	MG01LOG0007	  	; Controller CB = 03 CC = 01
					  	;
MG01LOG0002:	CJNE	A,#02h,MG01LOG0003  	; >> getDataBlockCount <<
					  	;
		CALL	GETMAXBLOCK  		; Controller CB = 03 CC = 02
		JMP	MAG01			;
			  			;
MG01LOG0003:	CJNE	A,#03h,MG01LOG0004  	; >> getDataBlock <<
					  	;
		JB	EXISTINGLOG,MAGGD	;
						;
		CALL	EMPTYBLOCK		; Send Empty Block
		JMP	MAG01DATAERR		;
						;
MAGGD:		CALL	GETDATAHEAD		; Controller CB = 03 CC = 03
		MOV	A,CONTSTATLO		; Test for errors
		JNZ	MAG01DATAERR		; Do not send data if errors
						;
		CALL	GETMAG01DATA		; Get and output data block
		JMP	MAG01			;
					  	;
MAG01DATAERR:	JP	LCDLOCAL,MAGERRLCD	; JUmp if in local mode
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getDataBlock    '      ;
		DB	03h		  	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      ' 		;
		DB	03h		  	;
MAGERRLCD:	JMP	MAG01			;
						;
MG01LOG0004:	CJNE	A,#04h,MG01LOG0005  	; >> getRate <<
					  	;
		CALL	GETRATE		  	; Controller CB = 03 CC = 04
		JMP	MAG01			;
						;
MG01LOG0005:	CJNE	A,#05h,MG01LOG0006  	; >> setRate <<
					  	;
		CALL	SETRATE			; Controller CB = 03 CC = 05
		JMP	MAG01			;
						;
MG01LOG0006:	CJNE	A,#06h,MG01LOG0007  	; >> capture <<
						;
		CALL	CAPTURE			; Controller CB = 03 CC = 06
		JMP	MAG01			;
						;
MG01LOG0007:	JMP	MG01INVALID		; Controller CB = 03 CC > 06
						; invalid command
						;
;
;>>>>>>>>>>> STARBASE INSTRUMENT FUNCTIONS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
MG01CB04:	MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,MG01IGAIN01  	; >> GET MAGNETOMETER GAIN <<
						;
		CALL	MG01GETGAIN	  	; Instrument CB = 04 CC = 00
		JMP	MAG01			;
			  			;
MG01IGAIN01:	CJNE	A,#01h,MG01XOUT  	; >> SET MAGNETOMETER GAIN <<
					  	;
		CALL	MG01SETGAIN	  	; Instrument CB = 04 CC = 01
		JMP	MAG01			;
						;
MG01XOUT:	CJNE	A,#02h,MG01YOUT  	; >> GET MAGNETOMETER X AXIS OUTPUT <<
					  	;
		CALL	MG01XAXIS  		; Instrument CB = 04 CC = 02
		JMP	MAG01			;
						;
MG01YOUT:	CJNE	A,#03h,MG01TEMP  	; >> GET MAGNETOMETER X AXIS OUTPUT <<
					  	;
		CALL	MG01YAXIS  		; Instrument CB = 04 CC = 03
		JMP	MAG01			;
						;
MG01TEMP:	CJNE	A,#04h,MG01NOFUNC	; >> GET MAGNETOMETER TEMPERATURE <<
						;
		CALL	MG01GETTEMP		; Instrument CB = 04 CC = 04
		JMP	MAG01			;
						;
MG01NOFUNC:	JMP	MG01INVALID		; Controller CB = 04 CC > 03
						; invalid command
						;
;
;>>>>>>>>>>> STARBASE BROADCAST <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
MG01BCADD:	CALL	DISCOVER		;
		JMP	MAG01			;
						;
;
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;///							                                 ///
;///     INSTRUMENT 03 - 21CM RECEIVER - VERSION 01 ASTROMETRICS                         ///
;///                                                                                     ///
;///     PLUGINS - A2h - Detector 			                                 ///
;///               A4h - 151/38   Downconverter - Gain & Channel                         ///
;///               A6h - 1420/151 Downconverter - Frequency                              ///
;///               A8h - Dicke Processor                                                 ///
;///               AAh - Spectral Receiver                                               ///
;///                                                                                     ///
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;
HYDROGEN01:	JMP	INITPROG		;


;
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;///							                                 ///
;///     INSTRUMENT 04 - MSF FREQUENCY STANDARD - VERSION 01 ASTROMETRICS                ///
;///                                                                                     ///
;///     PLUGINS - A2h - MSF RECEIVER                                                    ///
;///                                                                                     ///
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;
CLOCK01:	JMP	INITPROG		;


;
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;///							                                 ///
;///     INSTRUMENT 05 - ANTENNA CONTROLLER - VERSION 01 ASTROMETRICS                    ///
;///                                                                                     ///
;///     PLUGINS - A2h - ANTENNA CONTROLLER BOARD                                        ///
;///                                                                                     ///
;///////////////////////////////////////////////////////////////////////////////////////////
;///////////////////////////////////////////////////////////////////////////////////////////
;
;
;>>>>>>>>>>>>>> INITIALISE ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						;
ANTCNTRL01:	MOV	PROMMAP,#01h		; Calculate Total size of Config Blocks
		CALL	CALCMAXBLOCK		;
						;
		MOV	CFG832,#41h   	  	; Configure Processor Parmeters to
						; put PWM on 3.4/3.5
		MOV	PWM0L,#68h		;
		MOV	PWM0H,#10h		;
		MOV	PWM1L,#68h		;
		MOV	PWM1H,#10h		;
		MOV	PWMCON,#37h		; Set PWM Paramters
						;
		MOV	DEMAND0H,#08h		;
		MOV	DEMAND0L,#00h		;
		MOV	DEMAND1H,#08h		;
		MOV	DEMAND1L,#00h		;
						;
		MOV	TMOD,#09h		; Set Timer 0 Mode 1 (16 bit)
		MOV	TH0,#05h		; Set timer period to 1ms
		MOV	TL0,#76h		;
		SETB	TR0			; Start Timer 0
		SETB	ET0			; Enable Timer 0 Interupt
						;
;
;>>>>>>>>>>> RTOS ROUTINE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
						;
ANT01:		CLR	RXSTRGAV	  	; Reset Received String Flag bit
		CLR	CNTRLFLAG		; Control Data Input
		CLR	STRINGERR		; Clear String Error Flag
		CLR	TIMERFLAG		;
		CLR	A       	  	; Reset Bit 0 of DPCON to use main data ptr
		MOV	DPCON,A		  	;
		MOV	DPP,#00h	  	; Set Data Pointer to input buffer
		MOV	DPH,#00h	  	;
		MOV	DPL,#00h	  	;
						;
ANT01RXDAV:	JB	RXSTRGAV,ANT01TRLDAV  	; Jump if data available flag is raised
						;
		JB	T0FLAG,SERVO		; Jump if Timer 0 flag is raised
						;
		JB	CNTRLFLAG,GOANT01LOCAL	; Jump if local control data is available
						;
		JMP	ANT01RXDAV		; Loop until interupt data available
						;
GOANT01LOCAL:	JMP	ANT01LOCAL		;
						;
ANT01TRLDAV:	CALL	TESTSTRING		; Find end of buffer, address and errors
		JB	STRINGERR,ANT01		; If received string is errored restart
						;
		MOV	A,RCVDADD		;
		CJNE	A,#0FEh,ANT01NORMADD	; Look for BROADCAST address 0FEh
					  	;
		JMP	ANT01BCADD		; Broadcast Address Found
					  	;
SERVO:		MOV	A,PWM0H			; Test if Set = Demand
		CJNE	A,DEMAND0H,AZNOTEQUAL	; if not jump
						;
		MOV	A,PWM0L			;
		CJNE	A,DEMAND0L,AZNOTEQUAL	;
						;
		JMP	TESTELE			; If AZ already correct jump to test ele
						;
AZNOTEQUAL:	MOV	A,PWM0H			; Test if high byte of demand > Set
		CJNE	A,DEMAND0H,$+3		;
						;
		JC	AZDEMAND0LOW		;
						;
		MOV	A,PWM0L			; Demand < Set
		DEC	A			; Decrement Set
		MOV	PWM0L,A			; Save
		JNC	NOPWM0LUF		;
						;
		MOV	A,PWM0H			;
		DEC	A			;
		MOV	PWM0H,A			;
						;
NOPWM0LUF:	JMP	TESTELE			;
						;
AZDEMAND0LOW:	MOV	A,PWM0L			; Demand > Set
		INC	A			; Inc Set
		MOV	PWM0L,A			; Save
		JNC	TESTELE			;
						;
		MOV	A,PWM0H			;
		INC	A			;
		MOV	PWM0H,A			;
						;
TESTELE:	MOV	A,PWM1H			; Test if Set = Demand
		CJNE	A,DEMAND1H,ELENOTEQUAL	; if not jump
						;
		MOV	A,PWM1L			;
		CJNE	A,DEMAND1L,ELENOTEQUAL	;
						;
		JMP	RESETINT		; If Ele already correct jump to test ele
						;
ELENOTEQUAL:	MOV	A,PWM1H			; Test if high byte of demand > Set
		CJNE	A,DEMAND1H,$+3		;
						;
		JC	ELEDEMAND1LOW		;
						;
		MOV	A,PWM1L			; Demand < Set
		DEC	A			; Decrement Set
		MOV	PWM1L,A			; Save
		JNC	NOPWM1LUF		;
						;
		MOV	A,PWM1H			;
		DEC	A			;
		MOV	PWM1H,A			;
						;
NOPWM1LUF:	JMP	RESETINT		;
						;
ELEDEMAND1LOW:	MOV	A,PWM1L			; Demand > Set
		INC	A			; Inc Set
		MOV	PWM1L,A			; Save
		JNC	RESETINT		;
						;
		MOV	A,PWM1H			;
		INC	A			;
		MOV	PWM1H,A			;
						;
RESETINT:	CLR	T0FLAG			; Clear interupt flag
		JMP	ANT01			;
						;
;
;------------------------------------------------------------------------------------------
;
ANT01NORMADD:	CJNE	A,CONTADD,ANT01LOOP	; Compare to controller address and
					  	; loop if address does not match
						;
		CALL	GETFUNCTION		; Get CMDBASE and CMDCODE & Display on LCD
		JB	STRINGERR,ANT01LOOP	; If errored commands found loop
						;
		JMP	ANT01CCDEC		; Jump to decode command
						;
ANT01LOOP:	JMP	ANT01			; Loop
;
;-------------------------------------------------------------------------------------------
; Respond to local Control Inputs
;-------------------------------------------------------------------------------------------
ANT01LOCAL:	JMP	ANT01			; *** Routine to be added ***
						;
;
;>>>>>>>>>>> ROUTINE TO DECODE COMMAND TO BE EXECUTED <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
ANT01CCDEC:	MOV	A,CODEBASE	  	; Get Codebase in A
		CJNE	A,#00h,ANT01TRYCB01    	; If Commandbase is not 00h jump
  						;
		JMP	ANT01CB00	  	; Code Base = 00 Which is SB Core
					  	;
ANT01TRYCB01:	CJNE	A,#01h,ANT01TRYCB02    	; If Commandbase is not 01h jump
 					  	;
		JMP	ANT01CB01	  	; Code Base = 01 Which is SB Utilities
					  	;
ANT01TRYCB02:	CJNE	A,#02h,ANT01TRYCB03	; If Commandbase is not 02h jump
					  	;
		JMP	ANT01CB02	  	; Code Base = 02 Which is SB Analogue
						;
ANT01TRYCB03:	CJNE	A,#03h,ANT01INVALID	; If Commandbase is not 03h jump
					  	;
		JMP	ANT01CB03	  	; Code Base = 03 Which is instrument
					  	;
ANT01INVALID:	ANL	CONTSTATHI,#00h		; Set status Word for invalid command
		ANL	CONTSTATLO,#24h		;
		CALL	SENDHEAD	  	; Send STX, CONTADD
					  	; CODEBASE, CMDCODE and CONTSTAT
					  	;
		CALL	SENDCRC		  	; Send CRC and EOT string
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'            ' 	        ;
		DB	03h		  	;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Invalid Cmd     '      ;
		DB	03h		  	;
		JMP	ANT01			;
						;
;
;>>>>>>>>>>> STARBASE CORE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
ANT01CB00:	MOV	A,CMDCODE	  	;
		CJNE	A,#00h,ANT01CORE0001 	; >> RESET <<
					  	;
		CALL	PING			;
		JMP	INITPROG	   	; Controller CB = 00 CC = 00
					  	;
ANT01CORE0001:	CJNE	A,#01h,ANT01CORE0002  	; >> PING <<
					  	;
		CALL	PING	  		; Controller CB = 00 CC = 01
		JMP	ANT01			; Call Ping and loop
					  	;
ANT01CORE0002:	CJNE	A,#02h,ANT01CORE0003  	; >> GETCONFIG <<
					  	;
		JMP	ANT01INVALID		; Controller CB = 00 CC = 02
						; Invalid Command SB Virtual
						;
ANT01CORE0003:	CJNE	A,#03h,ANT01CORE0004	; >> GET MAX BLOCK <<
						;
		CALL	GETCNFGMAX		; Controller CB = 00 CC = 03
		JMP	ANT01			; Call to find size of XML
						;
ANT01CORE0004:	CJNE	A,#04h,ANT01CORE0005  	; >> GET BLOCK <<
					  	;
		CALL	GETCNFGBLOCK		; Controller CB = 00 CC = 04
		JMP	ANT01			; Call to get XML block and send
						;
ANT01CORE0005:	JMP	ANT01INVALID		; Invalid command - out of range
;
;>>>>>>>>>>> STARBASE UTILITIES <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
ANT01CB01:	MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,ANT01UTIL0001  	; >> GET DATE <<
						;
		CALL	GETRTCDATE	  	; Controller CB = 01 CC = 00
		JMP	ANT01			;
			  			;
ANT01UTIL0001:	CJNE	A,#01h,ANT01UTIL0002  	; >> SET DATE <<
					  	;
		CALL	SETRTCDATE	  	; Controller CB = 01 CC = 01
		JMP	ANT01			;
					  	;
ANT01UTIL0002:	CJNE	A,#02h,ANT01UTIL0003  	; >> GET TIME <<
					  	;
		CALL	GETRTCTIME	  	; Controller CB = 01 CC = 02
		JMP	ANT01			;
			  			;
ANT01UTIL0003:	CJNE	A,#03h,ANT01UTIL0004  	; >> SET TIME <<
					  	;
		CALL	SETRTCTIME	  	; Controller CB = 01 CC = 03
		JMP	ANT01		  	;
						;
ANT01UTIL0004:	CJNE	A,#04h,ANT01UTIL0005  	; >> GET CPU TEMPERATURE <<
					  	;
		CALL	GETCPUTEMP	  	; Controller CB = 01 CC = 04
		JMP	ANT01		  	;
						;
ANT01UTIL0005: 	CJNE	A,#05h,ANT01UTIL0006	; >> GET EEPROM <<
						;
		CALL	GETEEPROM		; Controller CB = 00 CC = 05
		JMP	ANT01		  	;
						;
ANT01UTIL0006:	CJNE	A,#06h,ANT01UTIL0007	; >> SET EEPROM <<
						;
		CALL	SETEEPROM		; Controller CB = 00 CC = 06
		JMP	ANT01		  	;
						;
ANT01UTIL0007:	CJNE	A,#07h,ANT01UTIL0008	; >> GET SERIAL NUMBER <<
						;
		CALL	GETSERIALNUM		; Controller CB = 00 CC = 07
		JMP	ANT01		  	;
						;
ANT01UTIL0008:	JMP	ANT01INVALID		; Controller CB = 00 CC > 07
						; invalid command
						;
;
;>>>>>>>>>>> STARBASE ANALOGUE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
ANT01CB02:	MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,ANT01ANALOG001 	; >> GET A2D <<
						;
		CALL	GETVALA2D	  	; Controller CB = 02 CC = 00
		JMP	ANT01			;
			  			;
ANT01ANALOG001:	CJNE	A,#01h,ANT01ANALOG002 	; >> GET D2A <<
					  	;
		CALL	GETVALD2A	  	; Controller CB = 02 CC = 01
		JMP	ANT01			;
					  	;
ANT01ANALOG002:	CJNE	A,#02h,ANT01ANALOG003 	; >> SET D2A <<
					  	;
		CALL	SETVALD2A	  	; Controller CB = 02 CC = 02
		JMP	ANT01			;
			  			;
ANT01ANALOG003:	JMP	ANT01INVALID		; Controller CB = 00 CC > 02
						; invalid command
						;
						;
;
;>>>>>>>>>>> STARBASE INSTRUMENT FUNCTIONS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
ANT01CB03:	MOV	A,CMDCODE	  	; Get Commandcode
						;
		CJNE	A,#00h,ANT01TRY01	; Instrument CB = 03 CC = 00
						;
		MOV	PWM0L,#68h		;
		MOV	PWM0H,#10h		; Center Servos
		CALL	LONGDELAY		;
		MOV	PWM1L,#68h		;
		MOV	PWM1H,#10h		;
		CALL	LONGDELAY		;
		ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		CALL	SENDHEAD		;
		CALL	SENDCRC			;
				  		;
		JMP	ANT01			;
						;
ANT01TRY01:	CJNE	A,#01h,ANT01TRY02	; Instrument CB = 03 CC = 01
						;
		CALL	ANT01ALT		;
		JMP	ANT01			;
						;
ANT01TRY02:	CJNE	A,#02h,ANT01TRY03	; Instrument CB = 03 CC = 02
						;
		CALL	ANT01AZ			;
ANT01TRY03:	JMP	ANT01			;
						;
;
;>>>>>>>>>>> STARBASE BROADCAST <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
;
ANT01BCADD:	CALL	DISCOVER		; >> DISCOVER <<
		JMP	ANT01			;
						;
;
;--------------------------------------------------------------------------
;	>> ANT01ALT <<
;--------------------------------------------------------------------------
;
ANT01ALT:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,ANT01NOSEP  	; If no separator end
					  	;
		JMP	ANT01SETALT	  	;
					  	;
ANT01NOSEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	ANT01ALTFAIL	  	;
						;
ANT01SETALT:	INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARD,A			; and save
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARC,A			;
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARB,A			;
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARA,A			;
						;
		MOV	ADH,#00h		; Clear Output registers
		MOV	ADL,#00h		;
						;
		MOV	R2,#03h			; Multiply by 1000
		MOV	R1,#0E8h		;
		MOV	R0,VARD			;
		CALL	MULT16BIT		;
		MOV	R2,#00h			; Multiply by 100
		MOV	R1,#64h			;
		MOV	R0,VARC			;
		CALL	MULT16BIT		;
		MOV	R2,#00h			; Multiply by 10
		MOV	R1,#0Ah			;
		MOV	R0,VARB			;
		CALL	MULT16BIT		;
		MOV	R2,#00h			; Multiply by 1
		MOV	R1,#01h			;
		MOV	R0,VARA			;
		CALL	MULT16BIT		;
						; Answer in ADH/ADL
						;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,LOOKANT01SEP  	; If no separator end
					  	;
		JMP	SETANT01ALT	  	;
					  	;
LOOKANT01SEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	ANT01ALTFAIL	  	;
						;
SETANT01ALT:	MOV	A,ADH			; Test for 4096 bits max
		CJNE	A,#10h,$+3		;
						;
		JC	ANT01ALTOK		;
						;
		JMP	ANT01ALTFAIL		;
						;
ANT01ALTOK:	CLR	C			; Add 1mS offset
		MOV	A,ADL			;
		ADD	A,#34h			;
		MOV	ADL,A			; Save
		MOV	A,ADH			;
		ADDC	A,#08h			;
		MOV	ADH,A			;
						;
		MOV	DEMAND0L,ADL		; Set Servo Position
		MOV	DEMAND0H,ADH		;
ANT01ALTFAIL:	CALL	SENDHEAD		;
		CALL	SENDCRC		  	;
		RET				;
						;
;
;
;--------------------------------------------------------------------------
;	>> ANT01AZ <<
;--------------------------------------------------------------------------
;
ANT01AZ:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,ANT01AZNOSEP  	; If no separator end
					  	;
		JMP	ANT01SETAZ	  	;
					  	;
ANT01AZNOSEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	ANT01AZFAIL	  	;
						;
ANT01SETAZ:	INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARD,A			; and save
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARC,A			;
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARB,A			;
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARA,A			;
						;
		MOV	ADH,#00h		; Clear OUtput registers
		MOV	ADL,#00h		;
						;
		MOV	R2,#03h			; Multiply by 1000
		MOV	R1,#0E8h		;
		MOV	R0,VARD			;
		CALL	MULT16BIT		;
		MOV	R2,#00h			; Multiply by 100
		MOV	R1,#64h			;
		MOV	R0,VARC			;
		CALL	MULT16BIT		;
		MOV	R2,#00h			; Multiply by 10
		MOV	R1,#0Ah			;
		MOV	R0,VARB			;
		CALL	MULT16BIT		;
		MOV	R2,#00h			; Multiply by 1
		MOV	R1,#01h			;
		MOV	R0,VARA			;
		CALL	MULT16BIT		;
						; Answer in ADH/ADL
						;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,LKANT01SEP  	; If no separator end
					  	;
		JMP	SETANT01AZ	  	;
					  	;
LKANT01SEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	ANT01AZFAIL	  	;
						;
SETANT01AZ:	MOV	A,ADH			; Test for 4096 bits max
		CJNE	A,#10h,$+3		;
						;
		JC	ANT01AZOK		;
						;
		JMP	ANT01AZFAIL		;
						;
ANT01AZOK:	CLR	C			; Add 1mS offset
		MOV	A,ADL			;
		ADD	A,#34h			;
		MOV	ADL,A			; Save
		MOV	A,ADH			;
		ADDC	A,#08h			;
		MOV	ADH,A			;
						;
		MOV	DEMAND1L,ADL		; Set Servo Position
		MOV	DEMAND1H,ADH		;
ANT01AZFAIL:	CALL	SENDHEAD		;
		CALL	SENDCRC		  	;
		RET				;
						;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVV                                                                                     VVV
;VVV                   COMMON FUNCTIONS - CORE / UTILITY / ANALOGUE                      VVV
;VVV                                                                                     VVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
;
;--------------------------------------------------------------------------
;	>> PING <<
;--------------------------------------------------------------------------
;
PING:		ANL	CONTSTATHI,#80h		; Clear Status Word
		ANL	CONTSTATLO,#00h		;
		CALL	SENDHEAD	  	; Send STX, CONTADD
					  	; CODEBASE, CMDCODE and CONTSTAT
					  	;
		CALL	SENDCRC		  	; Send CRC and EOT string
		JB	LCDLOCAL,NOPINGLCD	; Jump if in local mode
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'ping            '      ;
		DB	03h		  	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Add =   h   ' 		;
		DB	03h		  	;
						;
		MOV	A,#46h			; Set LCD Write Address
		CALL	SETLCDDISP		; Set data display position
		MOV	A,CONTADD		; Get address
		CALL	LCDVAL			; and display
						;
NOPINGLCD:	RET			  	; Return
					  	;
;
;--------------------------------------------------------------------------
;	>> GETCNFGMAX <<
;--------------------------------------------------------------------------
;
GETCNFGMAX:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
						;
		CALL	SENDHEAD		; Send header
		MOV	A,#1Fh			; Send US
		CALL	SENDCHAR		;
		MOV	A,CFGBLKMAXHI		; Get Block Count HI
		CALL	SENDVAL			; and send
		MOV	A,CFGBLKMAXLO		; Get Block Count LO
		CALL	SENDVAL			; and send
		MOV	A,#1Fh			; Send US
		CALL	SENDCHAR		;
		CALL	SENDCRC			;
MAXBLKFAIL:	JB	LCDLOCAL,NPGCFGLCD	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Max =     h ' 	        ;
		DB	03h		  	;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getConfBlockCnt '	;
		DB	03h		  	;
		MOV	A,#46h			; Set LCD Write Address
		CALL	SETLCDDISP		; Write Block size to LCD
		MOV	A,CFGBLKMAXHI		;
		CALL	LCDVAL			;
		MOV	A,CFGBLKMAXLO		;
		CALL	LCDVAL			;
						;
NPGCFGLCD:	RET				;
					  	;
;
;--------------------------------------------------------------------------
;	>> GETCNFGBLOCK <<
;--------------------------------------------------------------------------
;
GETCNFGBLOCK:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
					  	;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,BLKNOSEP	  	; If no separator end
					  	;
		CALL	READBYTE	  	; Read block address from buffer
		JB	VALIDHEX,BLKHIGET  	;
					  	;
		ORL	CONTSTATLO,#0Ah		; Status parameter error
		JMP	BLKREADFAIL	  	; Data Type error
					  	;
BLKHIGET:	MOV	CFGBLKHI,A		; Save Requested Block Hi byte
		CALL	READBYTE	  	; Read block address from buffer
		JB	VALIDHEX,BLKLOGET  	;
					  	;
		ORL	CONTSTATLO,#0Ah		; Set bit 5 of status byte
		JMP	BLKREADFAIL	  	; Data Type error
						;
BLKLOGET:	MOV	CFGBLKLO,A		; Save Requested Block Lo byte
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,BLKNOSEP	  	; If no separator end
					  	;
		JMP	JUMPGETPGHI	  	;
					  	;
BLKNOSEP:	ORL	CONTSTATLO,#12h		; Status = Format Error
		JMP	BLKREADFAIL	  	;
					  	;
JUMPGETPGHI:	MOV	A,CFGBLKHI		; Check that requested block is in limits
		CJNE	A,CFGBLKMAXHI,$+3	; When requested block less Carry set
						;
		JC	CFGBLKSIZEOK		; Jump if OK
						;
		MOV	A,CFGBLKHI		;
		CJNE	A,CFGBLKMAXHI,ERRINSIZE ; If not equal input is bigger than max
						;
 		MOV	A,CFGBLKLO		; If Hi block equal test Lo
		CJNE	A,CFGBLKMAXLO,$+3	; When requested block less Carry set
						;
		JC	CFGBLKSIZEOK		; Size is ok jump to continue
						;
		MOV	A,CFGBLKLO		;
		CJNE	A,CFGBLKMAXLO,ERRINSIZE ; If not equal input is bigger than max
						;
		JMP	CFGBLKSIZEOK		;
						;
ERRINSIZE:	ORL	CONTSTATLO,#0Ah		; Status = Parameter Error
		JMP	BLKREADFAIL	  	;
						;
CFGBLKSIZEOK:	MOV	MODULE,#0A0h	  	; Set module to controller EEPROM Address
		MOV	A,PROMMAP		;
		MOV	VARA,A			;
MODULETEST:	ANL	A,#01h			; Test bit 0
		JZ	GDBNOPROM		; Jump if no EEPROM
						;
		MOV	EEPROMH,#00h	  	; Set pointer to read page 0
		MOV	EEPROML,#00h	  	;
		CLR	NOACK			; Clear error flag
		CALL	READEEPROM	  	; Read first 128 bytes of EEPROM to Buffer
						;
		MOV	DPP,#00h		; Buffer Pointer
		MOV	DPH,#10h		;
		MOV	DPL,#03h		;
		CALL	READBYTE		; Get EOT Hi
		CLR	C			; Clear Carry Flag
		RRC	A			; Divide by 2 to get 512 byte block size max 7Eh
		MOV	VARB,A			; Save block count
						;
		MOV	A,CFGBLKHI		; Get Counter
		MOV	VARC,A			;
		MOV	A,CFGBLKLO		; Get Counter
		MOV	VARD,A			;
						;
		CLR	C			; Clear Carry
		SUBB	A,VARB			; Subtract Module size from requested Lo Byte
		MOV	VARD,A			; Save Result
		JNC	UPDATEBLOCK		; Jump if no underflow
						;
		MOV	A,VARC			; Decrement Hi byte and look for underflow
		CLR	C			;
		SUBB	A,#01h			;
		MOV	VARC,A			; Save
		JNC	UPDATEBLOCK		; Jump if No underflow to update and loop
						;
		MOV	A,CFGBLKLO		; Multiply
		MOV	B,#02h			; by 2 to get number of 256 byte pages
		MUL	AB			;
		MOV	CFGBLKLO,A		; Save LO byte
		MOV	VARB,B			; Save overflow
		MOV	A,CFGBLKHI		; Multiply
		MOV	B,#02h			; by 2
		MUL	AB			;
		CLR	C			;
		ADD	A,VARB			; Complete multiply
						;
		MOV	A,CFGBLKLO		;
		CLR	C			;
		ADD	A,#02h			; Add 2 x 256 byte pages = 512 byte offset
		MOV	CFGBLKLO,A		;
		JMP	GDBGETDATA		; Jump to recover and send block
						;
UPDATEBLOCK:	MOV	CFGBLKHI,VARC		; Save last calculation
		MOV	CFGBLKLO,VARD		;
						;
GDBNOPROM:	INC	MODULE			; Select next EEPROM
		INC	MODULE			;
		MOV	A,MODULE		; Test for end
		CJNE	A,#0B0h,TESTNEXTMOD	; Loop if not end
						;
		ORL	CONTSTATLO,#42h		; Invalid Address
		JMP	BLKREADFAIL	  	; Set Status and end
						;
TESTNEXTMOD:	MOV	A,VARA			; Recover temp prommap
		CLR	C			;
		RR	A			; Move prommap to test next module
		MOV	VARA,A			;
		JMP	MODULETEST		;
					  	;
GDBGETDATA:	CALL	SENDHEAD		; Start to send a data block to RS485
		MOV	A,#1Fh			; Send Separator
		CALL	SENDCHAR		;
		MOV	VARA,#02h		; Set loop counter to 2 x (128x2)
						;
		MOV	EEPROMH,CFGBLKLO	; Set EEPROM 256 byte Page
GDSENDLOOP:	MOV	EEPROML,#00h	  	; Set half page pointer to start
		CLR	NOACK			; Reset error flag
		CALL	READEEPROM	  	; Read 128 bytesinto buffer
		JNB	NOACK,XMLRDBUF1		; Jump if read ok
						;
CFGMODERR:	ORL	CONTSTATHI,#01h		;
		ORL	CONTSTATLO,#04h		; Invalid Address
		JMP	BLKREADFAIL	  	; Set Status and end
						;
XMLRDBUF1:	MOV	DPP,#00h	  	; Set XRAM buffer page pointer
		MOV	DPH,#10h		; for EEPROM area at 1000h
		MOV	DPL,#00h		;
						;
BLKRECOVER:	MOVX	A,@DPTR		  	; Get character from buffer
		INC	DPTR			; Increment pointer
		CALL	SENDCHAR		; Send to RS485
						;
		MOV	A,DPL		  	; Get lower byte of pointer and
		CJNE	A,#80h,BLKRECOVER  	; loop until end of 128 block
					  	;
		MOV	EEPROML,#80h	  	; Set pointer for 2nd half of 256 page
		CLR	NOACK
		CALL	READEEPROM	  	; Read into buffer
		JNB	NOACK,XMLRDBUF2		;
						;
		JMP	CFGMODERR		; Error reading EEPROM
						;
XMLRDBUF2:	MOV	DPP,#00h	  	; Set page pointer
		MOV	DPH,#10h		; Set EEPROM read buffer
		MOV	DPL,#00h		; to 01000h
						;
BLK2NDHALF:	MOVX	A,@DPTR		  	; Get character from buffer
		INC	DPTR			; Increment input pointer
		CALL	SENDCHAR		; Send to RS485
						;
		MOV	A,DPL		  	;
		CJNE	A,#80h,BLK2NDHALF  	; Loop for 128 characters
					  	;
		INC	EEPROMH			; Set EEPROM Hi pointer to next page
		DJNZ	VARA,GDSENDLOOP	  	; Loop to send upper 256 bytes
					  	;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send separator
						;
		CALL	SENDCRC			;
		JB	LCDLOCAL,CFGENDNOLCD	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Block Sent  ' 		;
		DB	03h		  	;
		JMP	CFENDMESS		;
						;
BLKREADFAIL:	CALL	SENDHEAD		;
		CALL	SENDCRC			;
		JB	LCDLOCAL,CFGENDNOLCD	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      ' 		;
		DB	03h		  	;
						;
CFENDMESS:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getConfigBlock  '	;
		DB	03h		  	;
CFGENDNOLCD:	RET				;
					  	;
;
;--------------------------------------------------------------------------
;	>> GETRTCDATE <<
;--------------------------------------------------------------------------
;
GETRTCDATE:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		CLR	NOACK			;
		CALL	GETDATE			; Place RTC registers in RAM
		JNB	NOACK,SENDDATE		; If no error Jump
						;
		ORL	CONTSTATLO,#42h		; Status = I2C error
		JMP	DATEERR			; and end
						;
SENDDATE:	JB	LCDLOCAL,SENDDATENOLCD	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		; and clear data area
		CALL	SENDSTRING	  	;
		DB	'            ' 	    	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
						;
SENDDATENOLCD:	CALL	SENDHEAD	  	;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
						;
		MOV	A,CENTTEN	  	;
		CALL	SENDCHAR	  	; Send '2'
		JB	LCDLOCAL,GD1		;
		CALL	WRITETOLCD		;
						;
GD1:		MOV	A,CENTUNIT	  	;
		CALL	SENDCHAR	  	; Send '0'
		JB	LCDLOCAL,GD2		;
		CALL	WRITETOLCD		;
					  	;
GD2:		MOV	A,YEAR		  	;
		SWAP	A		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of year
		JB	LCDLOCAL,GD3		;
		CALL	WRITETOLCD		;
					  	;
GD3:		MOV	A,YEAR		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of year
		JB	LCDLOCAL,GD4		;
		CALL	WRITETOLCD		;
					  	;
GD4:		MOV	A,#2Dh		  	;
		CALL	SENDCHAR	  	; Send -
		JB	LCDLOCAL,GD5		;
		CALL	WRITETOLCD		;
					  	;
GD5:		MOV	A,MONTH		  	;
		SWAP	A		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of month
		JB	LCDLOCAL,GD6		;
		CALL	WRITETOLCD		;
					  	;
GD6:		MOV	A,MONTH		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of month
		JB	LCDLOCAL,GD7		;
		CALL	WRITETOLCD		;
					  	;
GD7:		MOV	A,#2Dh		  	;
		CALL	SENDCHAR	  	; Send -
		JB	LCDLOCAL,GD8		;
		CALL	WRITETOLCD		;
					  	;
GD8:		MOV	A,DATE		  	;
		SWAP	A		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of Date
		JB	LCDLOCAL,GD9		;
		CALL	WRITETOLCD		;
					  	;
GD9:		MOV	A,DATE		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of date
		JB	LCDLOCAL,GD10		;
		CALL	WRITETOLCD		;
					  	;
GD10:		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
						;
		CALL	SENDCRC			; Send CRC
						;
		JB	LCDLOCAL,GETDATEEND	;
						;
		JMP	GETDATEDISP		;
					  	;
DATEERR:	CALL	SENDHEAD		; Send Status
		CALL	SENDCRC			;
		JB	LCDLOCAL,GETDATEEND	;
						;
GETDATEDISP:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getClockDate    '	;
		DB	03h		  	;
GETDATEEND:	RET	  			;
						;
;
;--------------------------------------------------------------------------
;	>> SETRTCDATE <<
;--------------------------------------------------------------------------
;
SETRTCDATE:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,NODATESEP  	; If no separator end
					  	;
		JMP	GETDATEDAT	  	;
					  	;
NODATESEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	DATEFAIL	  	; Format Error
						;
GETDATEDAT:	INC	DPTR			; Move pointer to start of data
		MOVX	A,@DPTR			;
		MOV	CENTTEN,A		; Get tens of century
						;
		INC	DPTR			; Move pointer to start of data
		MOVX	A,@DPTR			;
		MOV	CENTUNIT,A		; Get units of century
						;
		INC	DPTR		  	;
		MOVX	A,@DPTR		  	;
		MOV	TENYEAR,A	  	; Save tens of years
					  	;
		INC	DPTR		  	;
		MOVX	A,@DPTR		  	;
		MOV	YEAR,A	  	  	; Save units of years
					  	;
		INC	DPTR		  	;
		MOVX	A,@DPTR		  	;
		CJNE	A,#2Dh,SEPERR	  	; Check for '-'
					  	;
		INC	DPTR		  	;
		MOVX	A,@DPTR		  	;
		MOV	TENMONTH,A	  	; Save tens of months
					  	;
		INC	DPTR		  	;
		MOVX	A,@DPTR		  	;
		MOV	MONTH,A	    	  	; Save units of months
					  	;
		INC	DPTR		  	;
		MOVX	A,@DPTR		  	;
		CJNE	A,#2Dh,SEPERR	  	; Check for '-'

		INC	DPTR		  	; Increment DPTR to look at Data Field
		MOVX	A,@DPTR		  	;
		MOV	TENDATE,A	  	; Save tens of days
					  	;
		INC	DPTR		  	;
		MOVX	A,@DPTR		  	;
		MOV	DATE,A		  	; Save units of days
						;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,SEPERR  		; If no separator end
					  	;
		JMP	TEXTTORTC	  	;
					  	;
SEPERR:		ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP 	DATEFAIL		;
					  	;
TEXTTORTC:	MOV	A,TENDATE	  	; Manipulate ASCII into
		CLR	C		  	; form that can be sent
		SUBB	A,#30h	          	; to RTC
		SWAP	A		  	;
		ANL	A,#70h		  	;
		MOV	TENDATE,A	  	;
		MOV	A,DATE		  	;
		CLR	C		  	;
		SUBB	A,#30h		  	;
		ANL	A,#0Fh		  	;
		ORL	A,TENDATE	  	;
		MOV	DATE,A		  	;
					  	;
		MOV	A,TENMONTH	  	;
		CLR	C		  	;
		SUBB	A,#30h	          	;
		SWAP	A		  	;
		ANL	A,#10h		  	;
		MOV	TENMONTH,A	  	;
		MOV	A,MONTH		  	;
		CLR	C		  	;
		SUBB	A,#30h		  	;
		ANL	A,#0Fh		  	;
		ORL	A,TENMONTH	  	;
		MOV	MONTH,A	 	  	;
					  	;
		MOV	A,TENYEAR	  	;
		CLR	C		  	;
		SUBB	A,#30h	          	;
		SWAP	A		  	;
		MOV	TENYEAR,A	  	;
		MOV	A,YEAR		  	;
		CLR	C		  	;
		SUBB	A,#30h		  	;
		ANL	A,#0Fh		  	;
		ORL	A,TENYEAR	  	;
		MOV	YEAR,A		  	;
					  	;
		CALL	STARTBIT	  	;
		MOV	A,#0D0h		  	; DS1307 Address + Write
		CALL	SENDBYTE	  	;
		MOV	A,#04h		  	; Select Date register
		CALL	SENDBYTE	  	;
		MOV	A,DATE		  	;
		CALL	SENDBYTE	  	; Set Days Register
		MOV	A,MONTH		  	;
		CALL	SENDBYTE	  	; Set Month Register
		MOV	A,YEAR		  	;
		CALL	SENDBYTE	  	; Set Years Register
		MOV	A,#00h			; Set RTC COntrol Register
		CALL	SENDBYTE		;
		MOV	A,CENTTEN		;
		CALL	SENDBYTE		;
		MOV	A,CENTUNIT		;
		CALL	SENDBYTE		;
		CALL	STOPBIT		  	;
		JB	LCDLOCAL,SETDATEEND	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Date Set    ' 		;
		DB	03h		  	;
		JMP	SETDATEEND		;
						;
DATEFAIL:	JB	LCDLOCAL,SETDATEEND	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      ' 		;
		DB	03h		  	;
						;
SETDATEEND:	CALL	SENDHEAD		;
		CALL	SENDCRC		  	;
		JB	LCDLOCAL,SETDATEFIN	;
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'setClockDate    ' 	;
		DB	03h		  	;
SETDATEFIN:	RET				;
					  	;
;
;--------------------------------------------------------------------------
;	>> GETTRTCTIME <<
;--------------------------------------------------------------------------
;
GETRTCTIME:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		CALL	GETTIME			; Get RTC registers in RAM
		JNB	NOACK,ACCESSTIME	;
						;
		ORL	CONTSTATLO,#42h		; Status = I2C Error
		JMP	TIMEERR			; and end
						;
ACCESSTIME:	CALL	SENDHEAD		;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
		JB	LCDLOCAL,SENDTIMEHRS	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'            '		;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
					  	;					  	;
SENDTIMEHRS:	MOV	A,HOURS		  	;
		SWAP	A		  	;
		ANL	A,#03h		  	; Mask bits
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of Hours
		JB	LCDLOCAL,GT1		;
						;
		CALL	WRITETOLCD		;
						;
GT1:		MOV	A,HOURS 	  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of Hours
		JB	LCDLOCAL,GT2		;
						;
		CALL	WRITETOLCD		;
					  	;
GT2:		MOV	A,#3Ah		  	;
		CALL	SENDCHAR	  	; Send :
		JB	LCDLOCAL,GT3		;
						;
		CALL	WRITETOLCD		;
					  	;
GT3:		MOV	A,MINUTE	  	;
		SWAP	A		  	;
		ANL	A,#07h		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of Minutes
		JB	LCDLOCAL,GT4		;
						;
		CALL	WRITETOLCD		;
					  	;
GT4:		MOV	A,MINUTE	  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of Minutes
		JB	LCDLOCAL,GT5		;
						;
		CALL	WRITETOLCD		;
					  	;
GT5:		MOV	A,#3Ah		  	;
		CALL	SENDCHAR	  	; Send :
		JB	LCDLOCAL,GT6		;
						;
		CALL	WRITETOLCD		;
					  	;
GT6:		MOV	A,SECOND	  	;
		SWAP	A		  	;
		ANL	A,#07h		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of Seconds
		JB	LCDLOCAL,GT7		;
						;
		CALL	WRITETOLCD		;
					  	;
GT7:		MOV	A,SECOND	  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of Seconds
		JB	LCDLOCAL,GT8		;
						;
		CALL	WRITETOLCD		;
					  	;
GT8:		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
					  	;
		CALL	SENDCRC			; Send CRC
						;
		JB	LCDLOCAL,GETTIMEEND	;
						;
		JMP	GETTIMEDISP		;
					  	;
TIMEERR:	CALL	SENDHEAD		; Send Status
		CALL	SENDCRC			;
		JB	LCDLOCAL,GETTIMEEND	;
						;
GETTIMEDISP:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getClockTime    '	;
		DB	03h		  	;
GETTIMEEND:	RET	  			;
						;
;
;--------------------------------------------------------------------------
;	>> SETRTCTIME <<
;--------------------------------------------------------------------------
;
SETRTCTIME:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,NOTIMESEP  	; If no separator end
					  	;
		JMP	GETTIMEDAT	  	;
					  	;
NOTIMESEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	TIMEFAIL	  	;
						;
GETTIMEDAT:	INC	DPTR		  	; Increment DPTR to look at Data Field
		MOVX	A,@DPTR		  	;
		MOV	TENHOURS,A	  	; Save tens of hours
					  	;
		INC	DPTR		  	; Increment DPTR to look at Data Field
		MOVX	A,@DPTR		  	;
		MOV	HOURS,A		  	;
					  	;
		INC	DPTR		  	; Increment DPTR to look at Data Field
		MOVX	A,@DPTR		  	;
		CJNE	A,#3Ah,NODATEEND	;
					  	;
		INC	DPTR		  	; Increment DPTR to look at Data Field
		MOVX	A,@DPTR		  	;
		MOV	TENMINUTES,A	  	;
					  	;
		INC	DPTR		  	; Increment DPTR to look at Data Field
		MOVX	A,@DPTR		  	;
		MOV	MINUTE,A	  	;
					  	;
		INC	DPTR		  	; Increment DPTR to look at Data Field
		MOVX	A,@DPTR		  	;
		CJNE	A,#3Ah,NODATEEND	;
					  	;
		INC	DPTR		  	; Increment DPTR to look at Data Field
		MOVX	A,@DPTR		  	;
		MOV	TENSECONDS,A	  	;
					  	;
		INC	DPTR		  	; Increment DPTR to look at Data Field
		MOVX	A,@DPTR		  	;
		MOV	SECOND,A	  	;
					  	;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,NODATEEND  	; If no separator end
					  	;
		JMP	ASCIITORTC	  	;
					  	;
NODATEEND:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	TIMEFAIL	  	;
				          	;
ASCIITORTC:	MOV	A,TENHOURS	  	; Manipulate ASCII into
		CLR	C		  	; form that can be sent
		SUBB	A,#30h	          	; to RTC
		SWAP	A		  	;
		ANL	A,#30h		  	;
		MOV	TENHOURS,A	  	;
		MOV	A,HOURS		  	;
		CLR	C		  	;
		SUBB	A,#30h		  	;
		ANL	A,#0Fh		  	;
		ORL	A,TENHOURS	  	;
		MOV	HOURS,A		  	;
					  	;
		MOV	A,TENMINUTES	  	;
		CLR	C		  	;
		SUBB	A,#30h	          	;
		SWAP	A		  	;
		ANL	A,#70h		  	;
		MOV	TENMINUTES,A	  	;
		MOV	A,MINUTE	  	;
		CLR	C		  	;
		SUBB	A,#30h		  	;
		ANL	A,#0Fh		  	;
		ORL	A,TENMINUTES      	;
		MOV	MINUTE,A	  	;
					  	;
		MOV	A,TENSECONDS	  	;
		CLR	C		  	;
		SUBB	A,#30h	          	;
		SWAP	A		  	;
		ANL	A,#70h		  	;
		MOV	TENSECONDS,A	  	;
		MOV	A,SECOND	  	;
		CLR	C		  	;
		SUBB	A,#30h		  	;
		ANL	A,#0Fh		  	;
		ORL	A,TENSECONDS	  	;
		MOV	SECOND,A	  	;
					  	;
		CALL	STARTBIT	  	;
		MOV	A,#0D0h		  	; DS1307 Address + Write
		CALL	SENDBYTE	  	;
		MOV	A,#00h		  	; Select Seconds register
		CALL	SENDBYTE	  	;
		MOV	A,SECOND	  	;
		CALL	SENDBYTE	  	; Set Seconds Register
		MOV	A,MINUTE	  	;
		CALL	SENDBYTE	  	; Set Minutes Register
		MOV	A,HOURS		  	;
		CALL	SENDBYTE	  	; Set hours Register
		CALL	STOPBIT		  	;
					  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Time Set    ' 		;
		DB	03h		  	;
		JMP	SETTIMEEND		;
						;
TIMEFAIL:	CALL	SENDHEAD		;
		CALL	SENDCRC		  	;
		JB	LCDLOCAL,SETTIMEEND	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      ' 		;
		DB	03h		  	;
						;
SETTIMEEND:	CALL	SENDHEAD		;
		CALL	SENDCRC		  	;
		JB	LCDLOCAL,SETTIMEFIN	;
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'setClockTime     '	;
		DB	03h		  	;
SETTIMEFIN:	RET				;
					  	;

;
;--------------------------------------------------------------------------
;	>> GETCPUTEMP <<
;--------------------------------------------------------------------------
;
GETCPUTEMP:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
						;
		MOV	A,#08h			; Set ADC channel 8 = temp sensor
		CALL	GETADCVAL	  	; Get ADC Reading in data registers
					  	;
		CALL	SENDHEAD		;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
						;
		MOV	A,ADCDATAH	  	; Get ADC top bits
		CJNE	A,#83h,TOPLIM		; Test value is 03h or 04h
						;
		JMP	TESTTEMP03		; If ADCDATAH = 03 test for low limit
						;
TOPLIM:		CJNE	A,#84h,TEMPOOR1		; Jump if temperature out of range
						;
		MOV	A,ADCDATAL		; ADCDATAH = 04 test for upper limit
		CJNE	A,#75h,$+3		;
						;
		JNC	TEMPOOR2		; Jump if out of range
						;
		JMP	REALTEMP		; Jump if ok
						;
TESTTEMP03:	MOV	A,ADCDATAL		; ADCDATAH = 03 test for lower limit
		CJNE	A,#75h,$+3		;
						;
		JC	TEMPOOR3		; Jump if out of range
						;
REALTEMP:	MOV	A,#74h			; Temperature within limit 0 to 85 deg C
		CLR	C			; Reset Carry
		SUBB	A,ADCDATAL		; subtract reading from 474h to give a
						; remainder between FFh and 00h
		MOV	R0,#00h			; Clear loop counter
DIVBY3:		CLR	C			;
		SUBB	A,#03h			; Subtract 03h in loop to divide by 3
		JC	DIVRESULT		; until carry found
						;
		INC	R0			; Increment Counter
		JMP	DIVBY3			;
						;
DIVRESULT:	MOV	A,R0			; Result in A is integer temp in deg C
		MOV	R0,#00h			;
DECIMALLOOP:	CLR	C			;
		SUBB	A,#0Ah			; Divide by 10 in loop to decimalize
		JC	DECOUTPUT		;
						;
		INC	R0			;
		JMP	DECIMALLOOP		;
						;
DECOUTPUT:	CLR	C			;
		ADD	A,#0Ah			; Restore units R0 = Tens of deg C
		CLR	C			;
		ADD	A,#30h			; Make ASCII
		MOV	R1,A			; Save units
		MOV	A,R0			;
		CLR	C			;
		ADD	A,#30h			; Make tens ASCII
		MOV	R0,A			;
		JMP	OUTPUTTEMP		;
						;
TEMPOOR1:	MOV	R0,#35h			; Set output to 51 deg c
		MOV	R1,#31h			;
		JMP	OUTPUTTEMP		;
						;
TEMPOOR2:	MOV	R0,#35h			; Set output to 52 deg c
		MOV	R1,#32h			;
		JMP	OUTPUTTEMP		;
						;
TEMPOOR3:	MOV	R0,#35h			; Set output to 53 deg c
		MOV	R1,#33h			;
		JMP	OUTPUTTEMP		;
						;
OUTPUTTEMP:	MOV	A,R0			; Get tens
		MOV	VARD,R0			;
		CALL	SENDCHAR	  	; Output to serial port
						;
		MOV	A,R1			; Get units
		CALL	SENDCHAR	  	; Output to serial port
						;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
					  	;
		CALL	SENDCRC		  	;
						;
		JB	LCDLOCAL,CPUTEMPEND	; If LCD in local mode jump
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getTemperature  '	;
		DB	03h		  	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Temp =   C  ' 		;
		DB	03h		  	;
						;
		MOV	A,#47h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	LCDDELAY		;
		MOV	A,VARD			;
		CALL	WRITETOLCD		;
		MOV	A,R1			;
		CALL	WRITETOLCD		;
						;
CPUTEMPEND:	RET		  		; Return
						;
;
;--------------------------------------------------------------------------
;	>> GETVALA2D <<
;--------------------------------------------------------------------------
;
GETVALA2D:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,NOCHANSEP  	; If no separator end
					  	;
		JMP	GETCHANNUM	  	;
					  	;
NOCHANSEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	A2DFAIL		  	;
						;
GETCHANNUM:	CALL	READDECI		;
		CJNE	A,#09h,$+3		; Check ADC Channel
						;
		JC	READA2D			; Jump if 0 to 8
						;
		ORL	CONTSTATLO,#06h		; Status = Parameter Error
		JMP	A2DFAIL		  	; Errored data jump to restart
						;
READA2D:	MOV	R7,A			; Save channel
		CALL	GETADCVAL	  	; Get ADC Reading in data registers
					  	;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,ENDCHANSEP  	; If no separator end
					  	;
		JMP	MAKEADCREPLY	  	;
					  	;
ENDCHANSEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	A2DFAIL		  	;
						;
MAKEADCREPLY:	CALL	SENDHEAD		;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR		; Send US
						;
		MOV	A,ADCDATAH	  	; Get ADC top bits
		ANL	A,#0Fh			; Mask out channel nibble
		MOV	VARB,A			; Place in VARB
		MOV	VARA,ADCDATAL	  	; Get ADC lower bits in VARA
						;
		MOV	SCALEA,#06h		; Scaling factor for 2500mV
		MOV	SCALEB,#66h		;
		CALL	BA2V			; Call BCD Conversion
						;
		MOV	A,VARA			;
		CALL	SENDCHAR		;
						;
		MOV	A,VARB			;
		CALL	SENDCHAR		;
						;
		MOV	A,VARC			;
		CALL	SENDCHAR		;
						;
		MOV	A,VARD			;
		CALL	SENDCHAR		;
						;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
		CALL	SENDCRC			;
						;
		JB	LCDLOCAL,A2DEXIT	; If LCD in local mode jump
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'   =     mV ' 		;
		DB	03h		  	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		MOV	A,R7			; Recover Channel
		CALL	LCDVAL			; display channel on LCD
						;
		MOV	A,#45h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		MOV	A,VARA			;
		CALL	WRITETOLCD		; Display voltage
		MOV	A,VARB			;
		CALL	WRITETOLCD		;
		MOV	A,VARC			;
		CALL	WRITETOLCD		;
		MOV	A,VARD			;
		CALL	WRITETOLCD		;
		JMP	A2DEND			;
						;
A2DFAIL:	CALL	SENDHEAD		;
		CALL	SENDCRC			;
		JB	LCDLOCAL,A2DEXIT	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      ' 		;
		DB	03h		  	;
						;
A2DEND:		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getA2D          '	;
		DB	03h		  	;
						;
A2DEXIT:	RET				;
					  	;
;
;--------------------------------------------------------------------------
;	>> GETVALD2A <<
;--------------------------------------------------------------------------
;
GETVALD2A:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
						;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,DACNOSEP  	; If no separator end
					  	;
		JMP	GETDACCHAN	  	;
					  	;
DACNOSEP:	ANL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	D2AFAIL		  	;
						;
GETDACCHAN:	CALL	READDECI		;
		CJNE	A,#09h,$+3		; Check ADC Channel
						;
		JC	SAVEDACCHAN		; Jump if 0 to 8
						;
		ORL	CONTSTATLO,#06h		; Status = Parameter Error
		JMP	D2AFAIL		  	;
					  	;
SAVEDACCHAN:	MOV	R6,A	  		;
					  	;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,DACSEP2MIS  	; If no separator end
					  	;
		JMP	GETDACVAL	  	;
					  	;
DACSEP2MIS:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	D2AFAIL		  	;
					 	;
GETDACVAL:	CJNE	R6,#02h,$+3		; Test R6 = 0 or 1
						;
		JC	READDAC			;
					        ;
		ORL	CONTSTATLO,#06h		; Status = Data Type Error
		JMP	D2AFAIL			;
						;
READDAC:	CALL	SENDHEAD		;
  						;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
						;
		CJNE	R6,#00,GETDAC01		; Jump if channel 1
						;
		MOV	A,DAC0H		  	; Get DAC top bits
		ANL	A,#0Fh			; Mask lower nibble
		MOV	VARB,A			; Save
		MOV	VARA,DAC0L 	  	; Get DAC lower bits
		JMP	SENDTOPORT		;
						;
GETDAC01:	MOV	A,DAC1H		  	; Get DAC top bits
		ANL	A,#0Fh			; Mask lower nibble
		MOV	VARB,A			; Save
		MOV	VARA,DAC1L 	  	; Get DAC lower bits
						;
SENDTOPORT:	MOV	SCALEA,#06h		; Scaling factor for 2500mV
		MOV	SCALEB,#66h		;
						;
		CALL	BA2V			; Call BCD Conversion
						;
		MOV	A,VARA			; and send
		CALL	SENDCHAR		;
						;
		MOV	A,VARB			;
		CALL	SENDCHAR		;
						;
		MOV	A,VARC			;
		CALL	SENDCHAR		;
						;
		MOV	A,VARD			;
		CALL	SENDCHAR		;
						;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
		CALL	SENDCRC			;
					  	;
		JB	LCDLOCAL,D2AEND		; If LCD in local mode jump
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'   =     mV ' 		;
		DB	03h		  	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		MOV	A,R6			; Recover Channel
		CALL	LCDVAL			; display channel on LCD
						;
		MOV	A,#45h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		MOV	A,VARA			;
		CALL	WRITETOLCD		; Display voltage
		MOV	A,VARB			;
		CALL	WRITETOLCD		;
		MOV	A,VARC			;
		CALL	WRITETOLCD		;
		MOV	A,VARD			;
		CALL	WRITETOLCD		;
		JMP	D2AENDMESS		;
						;
D2AFAIL:	CALL	SENDHEAD		;
		CALL	SENDCRC			;
		JB	LCDLOCAL,D2AEND		;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      '		;
		DB	03h		  	;
						;
D2AENDMESS:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getD2A          '	;
		DB	03h		  	;
						;
D2AEND:		RET				;
					  	;
;
;--------------------------------------------------------------------------
;	>> SETVALD2A <<
;--------------------------------------------------------------------------
;
SETVALD2A:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,SETDACNOSEP  	; If no separator end
					  	;
		JMP	SETDACCHAN	  	;
					  	;
SETDACNOSEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	DACFAIL		  	;
						;
SETDACCHAN:	CALL	READDECI		;
		CJNE	A,#02,$+3		; Check ADC Channel
						;
		JC	WRDACCHAN		; Jump if 0 to 1
						;
		ORL	CONTSTATLO,#06h		; Status = Parameter Type Error
		JMP	DACFAIL		  	;
					  	;
WRDACCHAN:	MOV	DACCHAN,A		; Save Channel
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,SETDAC2SEP  	; If no separator end
					  	;
		JMP	GETDACDATA	  	;
					  	;
SETDAC2SEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	DACFAIL		  	;
						;
GETDACDATA:	INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARD,A			; and save
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARC,A			;
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARB,A			;
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARA,A			;
		CALL	BCD2HEX			; Convert to 16 bits ADH/ADL
						;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,LOOKDACSEP  	; If no separator end
					  	;
		JMP	SETDAC 		  	;
					  	;
LOOKDACSEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	DACFAIL		  	;
						;
SETDAC:		MOV	A,DACCHAN		;
		JZ	SETDAC0			; If DAC Chan = 0 jump
						;
		MOV	DAC1H,ADH		; Set DAC1
		MOV	DAC1L,ADL		;
		JMP	SETDACRESP		;
						;
SETDAC0:	MOV	DAC0H,ADH		; Set DAC1
		MOV	DAC0L,ADL		;
						;
SETDACRESP:	CALL	SENDHEAD		;
		CALL	SENDCRC		  	;
		JB	LCDLOCAL,DAEND	  	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'D2A Set     '		;
		DB	03h			;
		JMP	DACOK			;
		 				;
DACFAIL:	CALL	SENDHEAD		; Send Error Response
		CALL	SENDCRC			;
		JB	LCDLOCAL,DAEND		;
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      '		;
		DB	03h		  	;
						;
DACOK:		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'setD2A          '	;
		DB	03h		  	;
						;
DAEND:		RET				;
						;
;
;--------------------------------------------------------------------------
;	>> GET EEPROM <<
;--------------------------------------------------------------------------
;
GETEEPROM:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,MISSSEP	  	; If no separator end
					  	;
		JMP	GETMODH		  	;
					  	;
MISSSEP:	ORL	CONTSTATLO,#0Ah		; Set bit 4 of status byte
		JMP	READFAIL	  	; Format Error
					  	;
GETMODH:	CALL	READBYTE	  	; Read module address from buffer
		JB	VALIDHEX,ADDTEST  	;
					  	;
		ORL	CONTSTATLO,#06h		; Set bit 5 of status byte
		JMP	READFAIL	  	; Data Type error
					  	;
ADDTEST:	CJNE	A,#09h,$+3		; Test if A is 0 - 8
						;
		JC	CALCADD			; If data ok jump
						;
		ORL	CONTSTATLO,#42h		; Status = I2C Error
		JMP	READFAIL		;
						;
CALCADD:	MOV	B,#02h		  	; Calculate module address
		MUL	AB		  	;
		CLR	C		  	;
		ADD	A,#0A0h		  	;
		MOV	MODULE,A	  	;
					  	;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,NOSEP	  	; If no separator end
					  	;
		JMP	GETPGHI		  	;
					  	;
NOSEP:		ORL	CONTSTATLO,#0Ah		; Status = Format Error
		JMP	READFAIL	  	;
					  	;
GETPGHI:	CALL	READBYTE	  	; Read next page address from buffer
		JB	VALIDHEX,SAVEPG	  	;
					  	;
		ORL	CONTSTATLO,#06h		; Status = Data Type Error
		JMP	READFAIL	  	;
					  	;
SAVEPG:		MOV	EEPROMH,A	  	; Set EEPROM page address
		INC	DPTR		  	;
		MOVX	A,@DPTR		  	; Point at separator
		CJNE	A,#1Fh,SEPMISSED  	; If no separator end
					  	;
		JMP	F1002RES	  	;
					  	;
SEPMISSED:	ORL	CONTSTATLO,#10h		; Status = Parameter Error
		JMP	READFAIL		;
					  	;
F1002RES:	CLR	NOACK			; Reset error flag
		MOV	EEPROML,#00h	  	; Set half page pointer
		CALL	READEEPROM	  	; Read into buffer
		JNB	NOACK,XMLBUF1		; Jump if read ok
						;
		ORL	CONTSTATLO,#42h		; Status = I2C Error
		JMP	READFAIL		;
						;
XMLBUF1:	MOV	DPP,#00h	  	;
		MOV	OUTPTRHI,#08h		;
		MOV	OUTPTRLO,#00h		;
		MOV	INPTRHI,#10h		;
		MOV	INPTRLO,#00h		;
						;
RECOVER:	MOV	DPH,INPTRHI	  	; Set buffer pointer
		MOV	DPL,INPTRLO	  	;
		MOVX	A,@DPTR		  	; Get character from buffer
		INC	DPTR			; Increment input pointer
		MOV	INPTRHI,DPH		; and save
		MOV	INPTRLO,DPL		;
						;
		MOV	DPH,OUTPTRHI		; Load output pointer
		MOV	DPL,OUTPTRLO		;
		MOVX	@DPTR,A			; Save data in output buffer
		INC	DPTR			; Increment output pointer
		MOV	OUTPTRHI,DPH		; and save
		MOV	OUTPTRLO,DPL		;
		MOV	A,DPL		  	;
		CJNE	A,#80h,RECOVER	  	; Loop for 128 characters
					  	;
		MOV	EEPROML,#80h	  	; Set half page pointer
		CALL	READEEPROM	  	; Read into buffer
		JNB	NOACK,XMLXBUF2		;
						;
		ORL	CONTSTATLO,#42h		; Status = I2C Error
		JMP	READFAIL		;
						;
XMLXBUF2:	MOV	INPTRHI,#10h		;
		MOV	INPTRLO,#00h		;
						;
SECONDHALF:	MOV	DPH,INPTRHI	  	; Set buffer pointer
		MOV	DPL,INPTRLO	  	;
		MOVX	A,@DPTR		  	; Get character from buffer
		INC	DPTR			; Increment input pointer
		MOV	INPTRHI,DPH		; and save
		MOV	INPTRLO,DPL		;
						;
		MOV	DPH,OUTPTRHI		; Load output pointer
		MOV	DPL,OUTPTRLO		;
		MOVX	@DPTR,A			; Save data in output buffer
		INC	DPTR			; Increment output pointer
		MOV	OUTPTRHI,DPH		; and save
		MOV	OUTPTRLO,DPL		;
		MOV	A,DPL		  	;
		CJNE	A,#00h,SECONDHALF  	; Loop for 128 characters
					  	;
						; 256 bytes of data in buffer 0800 - 08FF
		CALL	SENDHEAD	  	;
					  	;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send separator
						;
		MOV	DPH,#08h		; Set pointer to output buffer
		MOV	DPL,#00h		;
XMLTXLOOP:	MOVX	A,@DPTR			; Get data
		CALL	SENDCHAR		;
		INC	DPTR			;
		MOV	A,DPL			;
		CJNE	A,#00h,XMLTXLOOP	; Loop for 256 bytes
						;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send separator
		CALL	SENDCRC		  	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Block Sent  ' 		;
		DB	03h		  	;
		JMP	GETPROMEND		;
						;
READFAIL:	CALL	SENDHEAD	  	;
		CALL	SENDCRC			;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      ' 		;
		DB	03h		  	;
						;
GETPROMEND:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getEEPROM       '	;
		DB	03h		  	;
		RET				;
					  	;
;
;--------------------------------------------------------------------------
;	>> SET EEPROM <<
;--------------------------------------------------------------------------
;
SETEEPROM:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,NOSXMLSEP  	; If no separator end
					  	;
		JMP	GETXMODULE	  	;
					  	;
NOSXMLSEP:	ORL	CONTSTATLO,#0Ah		; Status = Format Error
		JMP	WRITEFAIL	  	;
					  	;
GETXMODULE:	CALL	READBYTE	  	;
		JB	VALIDHEX,SAVEXMODULE 	; If ok jump to continue
					  	;
		ORL	CONTSTATLO,#06h		; Status = Data Type Error
		JMP	WRITEFAIL		;
					  	;
SAVEXMoDULE:	MOV	B,#02h		  	; Calculate address
		MUL	AB		  	;
		CLR	C		  	;
		ADD	A,#0A0h		  	;
		MOV	MODULE,A	  	; and save
						;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,NOSECSEP  	; If no separator end
					  	;
		JMP	GETXPGHI	  	;
					  	;
NOSECSEP:	ORL	CONTSTATLO,#0Ah		; Status = Format Error
		JMP	WRITEFAIL		;
					  	;
GETXPGHI:	CALL	READBYTE	  	;
		JB	VALIDHEX,SAVEXPAGE 	; If ok jump to continue
					  	;
		ORL	CONTSTATLO,#06h		; Status = Data Type Error
		JMP	WRITEFAIL		;
					  	;
SAVEXPAGE:	MOV	EEPROMH,A		; Set EEPROM Write Address
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,NOTRDSEP  	; If no separator end
					  	;
		JMP	GETXDATA	  	;
					  	;
NOTRDSEP:	ORL	CONTSTATLO,#0Ah		; Status = Format Error
		JMP	WRITEFAIL		; Format Error
					  	;
GETXDATA:	MOV	INPTRHI,DPH		; Save buffer pointer
		MOV	INPTRLO,DPL		;
		INC	DPTR			; Point at first data byte after US
		MOV	R1,#00h			; Clear R1 byte counter
		CLR	COUNT257		; Clear OF bit
						;
FINDTERMLOOP:	MOVX	A,@DPTR			; Get data and Test for Unit Sep
		CJNE	A,#1Fh,TEST256		; Jump if not
						;
		JMP	ENDTERMFND		; Jump when terminator found
						;
TEST256:	JNB	COUNT257,INCDATCNT	; Test if count = 257
						;
		ORL	CONTSTATLO,#06h		; Status = Data Type Error
		JMP	WRITEFAIL		; Jump to end
						;
INCDATCNT:	INC	DPTR			; Point at next data byte
		INC	R1			; Increment counter
		CJNE	R1,#00h,OFNOTSET	; If count not overflowed jump
						;
		SETB	COUNT257		; Set OF bit
OFNOTSET:	JMP	FINDTERMLOOP		; Loop
 						;
ENDTERMFND:	JB	COUNT257,GOGETDAT	; If US is char 257 continue
						;
		ORL	CONTSTATLO,#06h		; Status = Data Type Error
		JMP	WRITEFAIL		; If US is not char 257 end
						;
GOGETDAT:	MOV	OUTPTRHI,#10h		; Set output pointer
		MOV	OUTPTRLO,#00h		;
						;
DATARDLOOP:	MOV	DPH,INPTRHI		; Recover Data Pointer
		MOV	DPL,INPTRLO		;
		INC 	DPTR			; and point at data
		MOVX	A,@DPTR			; Get data
		MOV	INPTRHI,DPH		; and save
		MOV	INPTRLO,DPL		;
						;
		MOV	DPH,OUTPTRHI		; Load DPTR with output address
		MOV	DPL,OUTPTRLO		;
		MOVX	@DPTR,A			; Save Data
		INC	DPTR			; Increment Pointer
		MOV	OUTPTRHI,DPH		; Save output address
		MOV	OUTPTRLO,DPL		;
		MOV	A,DPL			; Test Output pointer for 128 bytes
		CJNE	A,#80h,DATARDLOOP	;
					  	;
		MOV	EEPROML,#00h		; Set page address
		CALL	WRITEEEPROM		; Write data to EEPROM
		JNB	NOACK,NEXT128		; Test for write error
						;
		ORL	CONTSTATLO,#42h		; Status = I2C Error
		JMP	WRITEFAIL		;
						;
NEXT128:	MOV	OUTPTRHI,#10h		; Set output pointer
		MOV	OUTPTRLO,#00h		;
						;
READLOOP:	MOV	DPH,INPTRHI		; Recover Data Pointer
		MOV	DPL,INPTRLO		;
		INC 	DPTR			; and point at data
		MOVX	A,@DPTR			; Get data
		MOV	INPTRHI,DPH		; and save
		MOV	INPTRLO,DPL		;
						;
		MOV	DPH,OUTPTRHI		; Load DPTR with output address
		MOV	DPL,OUTPTRLO		;
		MOVX	@DPTR,A			; Save Data
		INC	DPTR			; Increment Pointer
		MOV	OUTPTRHI,DPH		; Save output address
		MOV	OUTPTRLO,DPL		;
		MOV	A,DPL			; Test Output pointer for 128 bytes
		CJNE	A,#00h,READLOOP		;
					  	;
		MOV	EEPROML,#80h		; Set page address
		CALL	WRITEEEPROM		; Write data to EEPROM
		JNB	NOACK,WRITEGOOD		; Test for write error
						;
		ORL	CONTSTATLO,#42h		; Status = I2C Error
						;
WRITEFAIL:	MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      '		;
		DB	03h		  	;
		JMP	PROMWRITEEND		;
						;
WRITEGOOD:	MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Block Set   '		;
		DB	03h		  	;
						;
PROMWRITEEND:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'setEEPROM       '	;
		DB	03h		  	;
						;
		CALL	SENDHEAD	        ; Send response
		CALL	SENDCRC			; and send Tail
		RET				;
						;
;
;--------------------------------------------------------------------------
;	>> GETSERIALNUM <<
;--------------------------------------------------------------------------
;
GETSERIALNUM:	ANL	CONTSTATHI,#80h		; Clear Status Word
		ANL	CONTSTATLO,#00h		;
		CALL	SENDHEAD	  	; Send Header
		CALL	SENDCRC		  	; Send CRC and EOT string
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Serial Number   '      ;
		DB	03h		  	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'0101-100001 ' 		; *** SET SERIAL NUMBER HERE ***
		DB	03h		  	;
						;						;
		RET			  	; Return
						;
;
;--------------------------------------------------------------------------
;	>> GETSPACE <<
;--------------------------------------------------------------------------
;
GETSPACE:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		CALL	SENDHEAD		;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
						;
		MOV	A,LOGPTRPG		; Get logging pointer
		SWAP	A			; Shift lower nibble to Hi
		ANL	A,#0F0h			; and clear lower nibble
		MOV	VARA,A			; Save
						;
		MOV	A,LOGPTRHI		; Get logging Pointer
		SWAP	A			; Shift lower nibble
		ANL	A,#0Fh			; and clear upper nibble
		ORL	A,VARA			; and combine
		DEC	A			; Remove the 000180 offset
		MOV	VARA,A			; Save
						;
		MOV	A,#0FEh			; Translate data
		CLR	C			;
		SUBB	A,VARA			;
						;
		MOV	ADH,#00h		; Clear Registers
		MOV	ADL,#00h		;
		MOV	R0,A			;
		MOV	R1,#64h			; Set factor to 100d
		MOV	R2,#00h			;
		CALL	MULT16BIT		; Multiply A by 100d
						; Stored in ADH/ADL
		MOV	SCALEA,#00h		;
		MOV	SCALEB,#0FEh		; Set divisor to 254
						;
		CALL	AD2VD			; Divide ADH/ADL by 254
						; output in R2
						;
		JB	LCDLOCAL,SPACENOLCD	; Jump if LCD local
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getSpace        '	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Mem =    %  '		;
		DB	03h		  	;
		MOV	A,#46h			; Set LCD Write Address
		CALL	SETLCDDISP		;
						;
SPACENOLCD:	MOV	A,R2			;
		MOV	B,#100d			; Load Divisor with 100
		DIV	AB			; Divide A by B
		MOV	R4,A			; Save 100s
		MOV	A,B			; Get remainder
		MOV	B,#10d			; Load Divisor with 10
		DIV	AB			; Divide A by B
		MOV	R3,A			; Save 10s
		MOV	A,R4			; Recover 100s
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		JB	LCDLOCAL,SPACETENS	; Jump if LCD local
						;
		CALL	WRITETOLCD		;
SPACETENS:	MOV	A,R3			;
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		JB	LCDLOCAL,SPACEUNITS	; Jump if LCD local
						;
		CALL	WRITETOLCD		;
SPACEUNITS:	MOV	A,B			; Recover Units
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		JB	LCDLOCAL,SPACEEND	; Jump if LCD local
						;
		CALL	WRITETOLCD		;
SPACEEND:	MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
						;
		CALL	SENDCRC		  	;
		RET		  		; END
					  	;
;
;--------------------------------------------------------------------------
;	>> GETRATE <<
;--------------------------------------------------------------------------
;
GETRATE:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
						;
		MOV	VARB,PERIODHI		; Get Period Data
		MOV	VARA,PERIODLO		;
		MOV	SCALEB,#0E8h		; Set scaling factor
		MOV	SCALEA,#03h		;
		CALL	BA2V			; and convert to decimal
		CALL	SENDHEAD		; Send to RS485
		MOV	A,#1Fh			;
		CALL	SENDCHAR		; Send Seperator
		MOV	A,VARA			; Send 1000's
		CALL	SENDCHAR		;
		MOV	A,VARB			; Send 100's
		CALL	SENDCHAR		;
		MOV	A,VARC			; Send 10's
		CALL	SENDCHAR		;
		MOV	A,VARD			; Send Units
		CALL	SENDCHAR		;
		MOV	A,#1Fh			;
		CALL	SENDCHAR		; Send Seperator
		CALL	SENDCRC			;
		JB	LCDLOCAL,NORATELCD	; Jump if in local mode
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getRate         '	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Rate     s  '		;
		DB	03h		  	;
		MOV	A,#45h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		MOV	A,VARA			;
		CALL	WRITETOLCD		;
		MOV	A,VARB			;
		CALL	WRITETOLCD		;
		MOV	A,VARC			;
		CALL	WRITETOLCD		;
		MOV	A,VARD			;
		CALL	WRITETOLCD		;
NORATELCD:	RET				;
						;
;
;--------------------------------------------------------------------------
;	>> SETRATE <<
;--------------------------------------------------------------------------
;
SETRATE:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		JNB	LOGEN,SRVALID		; Jump if logging not active
						;
		ORL	CONTSTATLO,#04h		; Set Premature Termination
		JMP	SETRATEFAIL		; error bit and end
						;
SRVALID:	INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,SETRATENOSEP  	; If no separator end
					  	;
		JMP	SETRATEIN	  	;
					  	;
SETRATENOSEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	SETRATEFAIL	  	;
						;
SETRATEIN:	INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARD,A			; and save
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARC,A			;
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARB,A			;
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Data
		CLR	C			;
		SUBB	A,#30h			;
		MOV	VARA,A			;
						;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,SETRATENOSEP  	; If no separator end
						;
		MOV	ADH,#00h		; Clear OUtput registers
		MOV	ADL,#00h		;
						;
		MOV	R2,#03h			; Multiply by 1000
		MOV	R1,#0E8h		;
		MOV	R0,VARD			;
		CALL	MULT16BIT		;
		MOV	R2,#00h			; Multiply by 100
		MOV	R1,#64h			;
		MOV	R0,VARC			;
		CALL	MULT16BIT		;
		MOV	R2,#00h			; Multiply by 10
		MOV	R1,#0Ah			;
		MOV	R0,VARB			;
		CALL	MULT16BIT		;
		MOV	R2,#00h			; Multiply by 1
		MOV	R1,#01h			;
		MOV	R0,VARA			;
		CALL	MULT16BIT		;
						; Answer in ADH/ADL
		MOV	PERIODHI,ADH		;
		MOV	PERIODLO,ADL		;
		JB	LCDLOCAL,SETRATEEND	; Jump if LCD in Local
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Rate Set    ' 	   	;
		DB	03h		  	;
		JMP	SETRATEDISP		;
						;
SETRATEFAIL:	JB	LCDLOCAL,SETRATEEND	; Jump if LCD in local
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Set Reject  ' 	   	;
		DB	03h		  	;
						;
SETRATEDISP:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'setRate         '	;
		DB	03h		  	;
						;
SETRATEEND:	CALL	SENDHEAD	        ; Send response
		CALL	SENDCRC			; and send Tail
		RET				;
						;
;
;--------------------------------------------------------------------------
;	>> CAPTURE <<
;--------------------------------------------------------------------------
;
CAPTURE:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		INC	DPTR		  	; Point at separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,NOCAPSEP  	; No separator jump to error
					  	;
		INC	DPTR			; Get Boolean (Y or N)
		MOVX	A,@DPTR			;
		CJNE	A,#59h,TRYCAPN		; If character not = 'Y' jump to continue
						;
		JMP	CAPSTART		; Jump to start capture
						;
TRYCAPN:	CJNE	A,#4Eh,CAPERROR		; If Character not = 'N' jump to continue
					  	;
		JMP	CAPSTOP			; Jump to stop capture
						;
CAPERROR:	ORL	CONTSTATLO,#06h		; If not Y or N make Status = Data Type Error
		JMP	CAPFAIL		  	;
						;						;
CAPSTART:	INC	DPTR		  	; Point at separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,NOCAPSEP  	; No separator jump to error
					  	;
		JMP	SETCAPPOINT	  	; Continue if valid
						;
NOCAPSEP:	JMP	SNDFORMATERR		;
						;
SETCAPPOINT:	ORL	CONTSTATHI,#80h		; Set logging status indicator
		MOV	BLOCKHI,#00h		; Clear Block Counter
		MOV	BLOCKLO,#00h		;
		MOV	SAMCOUNT,#00h		; and Sample Counter
						;
		MOV	LOGPTRPG,#00h		; Load data pointer registers
		MOV	LOGPTRHI,#18h		; to 1800h
		MOV	LOGPTRLO,#00h 		;
						;
		SETB	NEWBLOCK		; Trigger interupt for new data block
		SETB	LOGEN			; Set logging enable bit
		SETB	EXISTINGLOG		; Set flag to show a log exists for maxblock
						;
		MOV	SEC,#00h	  	; Set interval timer
		MOV	INTVAL,PERIODLO	  	; Set logging period
		MOV	TIMECON,#13h	  	; Enable Interval timer
		JB	LCDLOCAL,NOCAPLCD	; Jump if in local mode
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		; Clear Data Area
		CALL	SENDSTRING	  	;
		DB	'Capturing   ' 		;
		DB	03h		  	;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Capture(Y)      '      ;
		DB	03h			;
NOCAPLCD:	JMP	CAPEND			;
						;
CAPSTOP:	INC	DPTR		  	; Capture (N) - Capture Stop routine
		MOVX	A,@DPTR		  	; Point at separator
		CJNE	A,#1Fh,SNDFORMATERR	; No separator jump to error
						;
		CLR	LOGEN			; Clear logging enable bit
		ANL	CONTSTATHI,#7Fh		; Clear Logging Status
		MOV	DPP,LOGPTRPG		; Load data pointer registers
		MOV	DPH,LOGPTRHI		; with last logging position
		MOV	DPL,LOGPTRLO 		;
		MOV	R0,SAMCOUNT		; Save Sample counter
		JMP	PADDATA			; Jump to pad data block
						;
SNDFORMATERR:	ORL	CONTSTATLO,#0Ah		; Status = Format Error
CAPFAIL:	JNB	LCDLOCAL,CAPDISPFAIL	;
						;
		JMP	CAPEND			;
						;
CAPDISPFAIL:	MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		; Clear Data Area
		CALL	SENDSTRING	  	;
		DB	'Failed      ' 		;
		DB	03h		  	;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Capture(N)      '      ;
		DB	03h			;
		JMP	CAPEND			;
						;
PADDATA:	JNB	NEWBLOCK,PADBLOCK	; Test if last sample was end of
						; a logging block (samcount = 0)
						; if data block is not full jump
		MOV	A,BLOCKLO		; If full the block count needs
		CLR	C			; correction
		SUBB	A,#01h			;
		MOV	BLOCKLO,A		;
		JNC	BLOCKCORR		;
						;
		DEC	BLOCKHI			;
BLOCKCORR:	JMP	WRITEBLOCKMAX		; Jump to write Max Block into data
						;
PADBLOCK:	MOV	A,#00h			;
		MOVX	@DPTR,A			; Write 00h to pad data block
		INC	DPTR			;
		MOV	A,#00h			;
		MOVX	@DPTR,A			;
		INC	DPTR			;
		MOV	A,#00h			;
		MOVX	@DPTR,A			;
		INC	DPTR			;
		MOV	A,#00h			;
		MOVX	@DPTR,A			;
		INC	DPTR			;
		MOV	A,R0			; Get Sample Count
		INC	A			; Increment to next
		MOV	R0,A			; and save
		CJNE	A,#3Dh,PADBLOCK		; Jump if not sample 61
						;
WRITEBLOCKMAX:	MOV	DPP,#00h		; Last block now filled to end, write
		MOV	DPH,#18h		; number of blocks into data
		MOV	DPL,#0Bh		; Set Pointer at first block
						; In max block position
						;
		MOV	R1,#00h			; Clear Max Block Counter
		MOV	R0,#00h			;
WRITEMAX:	MOV	A,BLOCKHI		;
		MOVX	@DPTR,A			; Write Max Block Data
		INC	DPTR			;
		MOV	A,BLOCKLO		;
		MOVX	@DPTR,A			;
						;
		MOV	A,R1			;
		CJNE	A,BLOCKHI,INCWRPOINT	; Test if all blocks written
						;
		MOV	A,R0			;
		CJNE	A,BLOCKLO,INCWRPOINT	; Do not jump if end reached
						;
		JMP	ALLBLOXDONE		;
						;
INCWRPOINT:	MOV	A,#01h			; Increment Counter LO
		ADD	A,R0			;
		JNC	NOOVERFLOW		; Jump if no Overflow
						;
		MOV	R0,A			; Save Counter LO
		MOV	A,#01h			; Increment Counter
		ADD	A,R1			;
		MOV	R1,A			;
		JMP	SETWRPOINT		; and continue
						;
NOOVERFLOW:	MOV	R0,A			; Save Block Count LO
						;
SETWRPOINT:	MOV	DPL,#0Bh		; Set Max block position
		MOV	A,#01h			;
		ADD	A,DPH			; Increment DPH
		JNC	SAVEBLOXHI		; Jump if no overflow
						;
		INC	DPP			; Increment Page Pointer
SAVEBLOXHI:	MOV	DPH,A			; Save DPH
		JMP	WRITEMAX		; and loop
						;
ALLBLOXDONE:	JB	LCDLOCAL,CAPEND		; Jump if in local mode
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		; Clear Data Area
		CALL	SENDSTRING	  	;
		DB	'Capture Off ' 		;
		DB	03h		  	;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Capture(N)      '      ;
		DB	03h			;
						;
CAPEND:		CALL	SENDHEAD		;
		CALL	SENDCRC		  	;
		RET				;
					  	;
;
;--------------------------------------------------------------------------
;	>> GETMAXBLOCK <<
;--------------------------------------------------------------------------
;
GETMAXBLOCK:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		JB	EXISTINGLOG,GMLOG	; Test if logging has occured
						; Jump if a log exists
		MOV	VARA,#00h		; If no logging set block count
		MOV	VARB,#00h		; to 0000h
		JMP	GMSEND			;
						;
GMLOG:		JNB	LOGEN,GMCORRECT		; Jump to continue if
						; logging is not enabled
		MOV	VARA,#00h		; If no logging set block count
		MOV	VARB,#00h		; to 0000h
		JMP	GMSEND			;
						;
GMCORRECT:	MOV	A,BLOCKLO		; Add offset of 1
		CLR	C			;
		ADD	A,#01h			;
		MOV	VARB,A			; Save Low block count
		JNC	NOCORROF		; Jump if no overflow
						;
		MOV	VARA,BLOCKHI		; Get Block high
		INC	VARA			; and increment for overflow
		JMP	GMSEND			; Jump to send
						;
NOCORROF:	MOV	VARA,BLOCKHI		;
GMSEND	:	CALL	SENDHEAD		;
		MOV	A,#1Fh			;
		CALL	SENDCHAR		;
		MOV	A,VARA			;
		CALL	SENDVAL			;
		MOV	A,VARB			;
		CALL	SENDVAL			;
		MOV	A,#1Fh			;
		CALL	SENDCHAR		;
		CALL	SENDCRC			;
		JB	LCDLOCAL,GETMAXEND	; Jump if in local mode
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		; Clear Data Area
		CALL	SENDSTRING	  	;
		DB	'Cnt =       ' 		;
		DB	03h		  	;
		MOV	A,#46h			; Set LCD Write Address
		CALL	SETLCDDISP		; Clear Data Area
		MOV	A,VARA			;
		CALL	LCDVAL			;
		MOV	A,VARB 			;
		CALL	LCDVAL			;
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getDataBlockCnt '      ;
		DB	03h			;
GETMAXEND:	RET				;
 						;

;
;--------------------------------------------------------------------------
;	>> EMPTYBLOCK <<
;--------------------------------------------------------------------------
;
EMPTYBLOCK:	ANL	CONTSTATHI,#80h		; Clear Status
		ORL	CONTSTATLO,#02h		; Set Abort
		CALL	SENDHEAD		;
		MOV	A,#1Fh			;
		CALL	SENDCHAR		;
		MOV	VARA,#0FFh		;
EMPBLOOP1:	MOV	A,#30h			; Send 256 0s
		CALL	SENDCHAR		;
		DJNZ	VARA,EMPBLOOP1		;
						;
		MOV	VARA,#0FFh		;
EMPBLOOP2:	MOV	A,#30h			; Send 256 0s
		CALL	SENDCHAR		;
		DJNZ	VARA,EMPBLOOP2		;
						;
		MOV	A,#1Fh			;
		CALL	SENDCHAR		;
		CALL	SENDCRC			;
		RET				;
;
;--------------------------------------------------------------------------
;	>> GETDATAHEAD <<
;--------------------------------------------------------------------------
;
GETDATAHEAD:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		JNB	LOGEN,GETDATVALID	; Jump to continue if
						; logging is not enabled
		ORL	CONTSTATLO,#04h		; Set early termination bit
		JB	LCDLOCAL,GETDATSTOP	; Jump if in local mode
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getDataBlock    '	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Capturing   '		;
		DB	03h		  	;
GETDATSTOP:	CALL	SENDHEAD		;
		CALL	SENDCRC			;
		JMP	GETDATEND		; Jump to Exit
						;
GETDATVALID:	INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,GETDATNOSEP  	; If no separator end
					  	;
		JMP	GETDATRDBLK	  	; Jump to read data block
					  	;
GETDATNOSEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JB	LCDLOCAL,GETDATFORM	; Jump if in local mode
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getDataBlock    '	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Bad Format  '		;
		DB	03h		  	;
GETDATFORM:	CALL	SENDHEAD		;
		CALL	SENDCRC			;
		JMP	GETDATEND		; Jump to Exit
						;
GETDATRDBLK:	CALL	READBYTE		; Read first Byte of Block
		MOV	R4,A			; Save Block Hi in R4
		CALL	READBYTE		; Read second Byte of Block
		MOV	R3,A			; Save Block Lo in R3
		INC	DPTR			;
		MOVX	A,@DPTR			;
		CJNE	A,#1Fh,GETDATNOSEP	;
						;
		MOV	VARD,BLOCKLO		; Get max block size and
		MOV	VARC,BLOCKHI		; increment before test
		MOV	A,#01h			;
		CLR	C			; Reset Carry Flag
		ADD	A,VARD 			; Increment VARD = Blocklo
		MOV	VARD,A			;
		JNC	GETDATINCBLOX		;
						;
		INC	VARC			; Increment Blockhi if carry
GETDATINCBLOX:	MOV	A,R4			; Get Max Hi
		CJNE	A,VARC,$+3		; Test if Request is less than max
						;
		JC	GBSIZEVALID		;
						;
		MOV	A,R3			; Get Max Lo
		CJNE	A,VARD,$+3		; Test if Request is less than max
						;
		JC	GBSIZEVALID		;
						;
		ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JB	LCDLOCAL,GETDATBSIZE	; Jump if in local mode
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getDataBlock    '	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Size Error  '		;
		DB	03h		  	;
GETDATBSIZE:	CALL	SENDHEAD		;
		CALL	SENDCRC			;
		JMP	GETDATEND		; Jump to Exit
						;
GBSIZEVALID:	MOV	R2,#00h			; Requested block in limits
		MOV	A,#18h			;
		CLR	C			;
		ADD	A,R3			; add offset to high pointer to
		MOV	R3,A			;
		JNC	GDINCHI			; Calculate block address
						;
		INC	R4			; Increment page pointer if overflow
GDINCHI:	MOV	DPP,R4			; Move block address to pointers
		MOV	DPH,R3			;
		MOV	DPL,R2			;
						;
		CALL	SENDHEAD		; Start sending response
		MOV	A,#1Fh			;
		CALL	SENDCHAR		; Send US
						;
		MOV	A,#32h			;
		CALL	SENDCHAR		; Send '2'
						;
		MOVX	A,@DPTR			; Read Century Unit from header
		INC	DPTR			;
		CALL	SENDCHAR		; Send
						;
		MOVX	A,@DPTR			; Read Year from header
		INC	DPTR			;
		MOV	VARD,A			; Save
		SWAP	A		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of year
		MOV	A,VARD		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of year
						;
		MOV	A,#2Dh			;
		CALL	SENDCHAR		; Send '-'
						;
		MOVX	A,@DPTR			; Read Month from header
		INC	DPTR			;
		MOV	VARD,A			; Save
		SWAP	A		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of Month
		MOV	A,VARD		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of Month
						;
		MOV	A,#2Dh			;
		CALL	SENDCHAR		; Send '-'
						;
		MOVX	A,@DPTR			; Read Day from header
		INC	DPTR			;
		MOV	VARD,A			; Save
		SWAP	A		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of Days
		MOV	A,VARD		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of Day
						;
		MOV	A,#20h			;
		CALL	SENDCHAR		; Send 'Space'
						;
		MOVX	A,@DPTR			; Read Hours from header
		INC	DPTR			;
		MOV	VARD,A			; Save
		SWAP	A		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of Hours
		MOV	A,VARD		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of Hours
						;
		MOV	A,#3Ah			;
		CALL	SENDCHAR		; Send ':'
						;
		MOVX	A,@DPTR			; Read Minutes from header
		INC	DPTR			;
		MOV	VARD,A			; Save
		SWAP	A		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of Minutes
		MOV	A,VARD		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of Minutes
						;
		MOV	A,#3Ah			;
		CALL	SENDCHAR		; Send ':'
						;
		MOVX	A,@DPTR			; Read Seconds from header
		INC	DPTR			;
		MOV	VARD,A			; Save
		SWAP	A		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 10's of Seconds
		MOV	A,VARD		  	;
		ANL	A,#0Fh		  	;
		ORL	A,#30h		  	;
		CALL	SENDCHAR	  	; Send 1's of Seconds
						;
		MOV	A,#20h			;
		CALL	SENDCHAR		; Send 'Space'
;
; >>> Insert temperature of 1st instrument module <<<
;
		MOV	A,#98h			; Set Magnetometer LM73 I2C
		CALL	LM73READ		; Read Temperature
		JNB	NEGVAL,GHTPOS		; Jump if temperature negative
						;
		MOV	VARA,A			; Save negative Value
		MOV	A,#00h			; Load A with 00h
		CLR	C			;
		SUBB	A,VARA			; and subtract value to convert
						;
GHTPOS:		MOV	VARA,A			; Save value
		JB	NEGVAL,GHIND		; Jump if Negative Value
						;
		MOV	A,#2Bh			; Send '+'
		CALL	SENDCHAR		;
		JMP	GHVALSEND		;
						;
GHIND:		MOV	A,#2Dh			; Send '-'
		CALL	SENDCHAR		;
GHVALSEND:	MOV	A,VARA			;
		MOV	B,#100d			; Load Divisor with 100
		DIV	AB			; Divide A by B
		MOV	R4,A			; Save 100s
		MOV	A,B			; Get remainder
		MOV	B,#10d			; Load Divisor with 10
		DIV	AB			; Divide A by B
		MOV	R3,A			; Save 10s
		MOV	A,R4			; Recover 100s
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		MOV	A,R3			;
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		MOV	A,B			; Recover Units
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
						;
		MOV	A,#20h			;
		CALL	SENDCHAR		; Send 'Space'
						;
;
; >>> Insert Sampling Rate <<<
;
		MOV	VARB,PERIODHI		; Get Period Data
		MOV	VARA,PERIODLO		;
		MOV	SCALEB,#0E8h		; Set scaling factor
		MOV	SCALEA,#03h		;
		CALL	BA2V			; and convert to decimal
		MOV	A,VARA			; Send 1000's
		CALL	SENDCHAR		;
		MOV	A,VARB			; Send 100's
		CALL	SENDCHAR		;
		MOV	A,VARC			; Send 10's
		CALL	SENDCHAR		;
		MOV	A,VARD			; Send Units
		CALL	SENDCHAR		;
						;
		MOV	A,#20h			; Pad to end of header
		CALL	SENDCHAR		; Send 'Space'
		CALL	SENDCHAR		; Send 'Space'
		CALL	SENDCHAR		; Send 'Space'
						;
GETDATEND:	RET				;
						;
;
;--------------------------------------------------------------------------
;	>> GETVLF01DATA <<
;--------------------------------------------------------------------------
;
GETVLF01DATA:	MOV	DPL,#10h		; Move buffer pointer to data
		MOV	XRCOUNT,#78h		; Set counter
						;
GETVLF01BLKLP:	MOVX	A,@DPTR			; Get Data Hi
		ANL	A,#0Fh			; Mask out channel nibble

		MOV	VARB,A			; Save ADC Hi byte
		INC	DPTR			;
		MOVX	A,@DPTR			; Get Data Lo
		MOV	VARA,A			; Save ADC Lo byte
		INC	DPTR			;
						;
		MOV	SCALEA,#06h		; Scaling factor for 2500mV
		MOV	SCALEB,#66h		;
		CALL	BA2V			; Call BCD Conversion
						;
		MOV	A,VARA			;
		CALL	SENDCHAR		;
						;
		MOV	A,VARB			;
		CALL	SENDCHAR		;
						;
		MOV	A,VARC			;
		CALL	SENDCHAR		;
						;
		MOV	A,VARD			;
		CALL	SENDCHAR		;
						;
		DJNZ	XRCOUNT,GETVLF01BLKLP	; Loop to send all data
						;
		MOV	A,#1Fh			;
		CALL	SENDCHAR		;
		CALL	SENDCRC			;
		JB	LCDLOCAL,NOGETVLF01LCD	;
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getDataBlock    '	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Sending     '		;
		DB	03h		  	;
NOGETVLF01LCD:	RET				;
 						;
;
;--------------------------------------------------------------------------
;	>> VLF01GETTEMP <<
;--------------------------------------------------------------------------
;
VLF01GETTEMP:	MOV	A,#98h			; Set VLF Rx LM73 I2C
		CALL	LM73READ		; Read Temperature
		JNB	NEGVAL,VLF01TPOS	; Jump if temperature negative
						;
		MOV	VARA,A			; Save negative Value
		MOV	A,#00h			; Load A with 00h
		CLR	C			;
		SUBB	A,VARA			; and subtract value to convert
						;
VLF01TPOS:	MOV	VARA,A			; Save value
						;
		ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		CALL	SENDHEAD  		; Send header
		MOV	A,#1Fh			;
		CALL	SENDCHAR		;
						;
		JB	LCDLOCAL,VLF01SIGN	; Test if in local mode
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getTemperature  '	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Temp     C  '		;
		DB	03h		  	;
		MOV	A,#45h			; 2nd line of LCD
		CALL	SETLCDDISP		;
						;
VLF01SIGN:	JB	NEGVAL,VLF01IND		; Jump if Negative Value
						;
		MOV	A,#2Bh			; Send '+'
		CALL	SENDCHAR		;
		JB	LCDLOCAL,VLF01VALSEND	;
						;
		CALL	WRITETOLCD		;
		JMP	VLF01VALSEND		;
						;
VLF01IND:	MOV	A,#2Dh			; Send '-'
		CALL	SENDCHAR		;
		JB	LCDLOCAL,VLF01VALSEND	;
						;
		CALL	WRITETOLCD		;
VLF01VALSEND:	MOV	A,VARA			;
		MOV	B,#100d			; Load Divisor with 100
		DIV	AB			; Divide A by B
		MOV	R4,A			; Save 100s
		MOV	A,B			; Get remainder
		MOV	B,#10d			; Load Divisor with 10
		DIV	AB			; Divide A by B
		MOV	R3,A			; Save 10s
		MOV	A,R4			; Recover 100s
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		JB	LCDLOCAL,VLFLCD10	; Test if in local mode
						;
		CALL	WRITETOLCD		;
VLFLCD10:	MOV	A,R3			;
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		JB	LCDLOCAL,VLFLCDUNIT	; Test if in local mode
						;
		CALL	WRITETOLCD		;
VLFLCDUNIT:	MOV	A,B			; Recover Units
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		JB	LCDLOCAL,VLFLCDFIN	; Test if in local mode
						;
VLFLCDFIN:	CALL	WRITETOLCD		;
		MOV	A,#1Fh			; Send US
		CALL	SENDCHAR		;
		CALL	SENDCRC			;
		RET				;
						;
;
;--------------------------------------------------------------------------
;	>> GETMAG01DATA <<
;--------------------------------------------------------------------------
;
GETMAG01DATA:	MOV	DPL,#10h		; Move buffer pointer to data
		MOV	XRCOUNT,#3Ch		; Set counter
						;
GETMAG01BLKLP:	MOVX	A,@DPTR			; Get X Data Hi
		MOV	VARB,A			;
		INC	DPTR			;
		MOVX	A,@DPTR			; Get X Data Lo
		MOV	VARA,A			;
		CALL	MAGLOGOUT		;
		INC	DPTR			;
		MOVX	A,@DPTR			; Get Y Data Hi
		MOV	VARB,A			;
		INC	DPTR			;
		MOVX	A,@DPTR			; Get Y Data Lo
		MOV	VARA,A			;
		CALL	MAGLOGOUT		;
		INC 	DPTR			;
		DJNZ	XRCOUNT,GETMAG01BLKLP	;
						;
		MOV	A,#1Fh			;
		CALL	SENDCHAR		;
		CALL	SENDCRC			;
		JB	LCDLOCAL,NOGETMAG01LCD	;
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getDataBlock    '	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Sending     '		;
		DB	03h		  	;
NOGETMAG01LCD:	RET				;
 						;
;
;--------------------------------------------------------------------------
;	>> MG01GETGAIN <<
;--------------------------------------------------------------------------
;
MG01GETGAIN:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		CLR	NOACK	  		; Reset I2C error flag
		CALL	STARTBIT		;
		MOV	A,#20h			; Write magnetometer address 20h
		CALL	SENDBYTE		;
		MOV	A,#00h			; Select gain register
		CALL	SENDBYTE		;
		CALL	STOPBIT			;
						;
		CALL	STARTBIT	  	;
		MOV	A,#021h		  	; Write magnetometer address + Read
		CALL	SENDBYTE	  	;
		SETB	LASTBYTE		; Signal Last BYte Read
		CALL	RCVBYTE			;
		CALL	STOPBIT			;
		JNB	NOACK,DISPGAIN		; If no errors jump
						;
		JMP	GETGAINERR		;
						;
DISPGAIN:	CALL	SENDHEAD		;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
		MOV	A,I2CRXBUF   		;
		ADD	A,#30h			; Convert to decimal
		MOV	R1,A			; Save gain value
		CALL	SENDCHAR		;
		MOV	A,#1Fh			; Send US
		CALL	SENDCHAR		;
		CALL	SENDCRC			;
						;
		JB	LCDLOCAL,NOMG01LCDEND	;
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Gain =      '		;
		DB	03h			;
		MOV	A,#47h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		MOV	A,R1			;
		CALL	WRITETOLCD		;
		JMP	GAINOK			;
						;
GETGAINERR:	ORL	CONTSTATHI,#01h		; Set I2C error status
		CALL	SENDHEAD		;
		CALL	SENDCRC			;
		JB	LCDLOCAL,NOMG01LCDEND	;
						;
GAINOK:		DB	03h		  	;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getGain         '	;
		DB	03h		  	;
						;
NOMG01LCDEND:	RET		  		; Return
						;
;
;--------------------------------------------------------------------------
;	>> MG01SETGAIN <<
;--------------------------------------------------------------------------
;
MG01SETGAIN:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,SETGAINNOSEP  	; If no separator end
					  	;
		JMP	SETGAINLEVEL	  	;
					  	;
SETGAINNOSEP:	ORL	CONTSTATLO,#0Ah		; Status = Data Format Error
		JMP	SETGAINFAIL	  	;
						;
SETGAINLEVEL:	INC	DPTR			;
		MOVX	A,@DPTR			; Get Gain Byte
		SUBB	A,#30h			; Convert ASCII to Binary
		JZ	GAINDATAERR		; If A = 00h jump error
						;
		CJNE	A,#05h,$+3		; Check max Gain = 4
						;
		JC	WRGAINDATA		; Jump if <4
						;
GAINDATAERR:	ORL	CONTSTATLO,#06h		; Status = Parameter Type Error
		JMP	SETGAINFAIL		;
					  	;
WRGAINDATA:	MOV	VARA,A			; Save Gain
		INC	DPTR		  	; Move to separator
		MOVX	A,@DPTR		  	;
		CJNE	A,#1Fh,SETGAINNOSEP  	; If no separator end
						;
		CLR	NOACK	  		; Reset I2C error flag
		CALL	STARTBIT		;
		MOV	A,#20h			; Write magnetometer address 20h
		CALL	SENDBYTE		;
		MOV	A,#00h			; Select gain register
		CALL	SENDBYTE		;
		MOV	A,VARA			; Set Gain
		CALL	SENDBYTE		;
		CALL	STOPBIT			;
		JNB	NOACK,SETGAINOK		; If no errors jump
						;
		ORL	CONTSTATHI,#01h		; Status = I2C Error
						;
SETGAINFAIL:	CALL	SENDHEAD		;
		CALL	SENDCRC			;
		JB	LCDLOCAL,NOMG01LCD	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Failed      '		;
		DB	03h		  	;
		JMP	MG01MESSLCD		;
						;
SETGAINOK:	CALL	SENDHEAD		;
		CALL	SENDCRC			;
		JB	LCDLOCAL,NOMG01LCD	;
						;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Set         '		;
		DB	03h		  	;
					  	;
MG01MESSLCD:	MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'setGain         '	;
		DB	03h		  	;
						;
NOMG01LCD:	RET		  		; Return
						;
;
;--------------------------------------------------------------------------
;	>> MG01XOUT <<
;--------------------------------------------------------------------------
;
MG01XAXIS:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		CLR	LASTBYTE		;
		CLR	NOACK	  		; Reset I2C error flag
		CALL	STARTBIT		;
		MOV	A,#20h			; Write magnetometer address 20h
		CALL	SENDBYTE		;
		MOV	A,#01h			; Select X Axis Hi register
		CALL	SENDBYTE		;
		CALL	STARTBIT	  	;
		MOV	A,#021h		  	; Write magnetometer address + Read
		CALL	SENDBYTE	  	;
		CALL	RCVBYTE			;
		MOV	VARB,I2CRXBUF		; Get X Axis High
		SETB	LASTBYTE		; Signal Last BYte Read
		CALL	RCVBYTE			;
		MOV	VARA,I2CRXBUF		; Get X Axis Lo
		CALL	STOPBIT			;
		JNB	NOACK,XPOL		; If no errors jump
						;
		JMP	GETXERR			;
						;
XPOL:		MOV	A,VARB			; Get X High
		ANL	A,#02h			; Mask bit 9
		JZ	XNEGOUT			; Jump if a negative number
						;
		CLR	NEGVAL			; Clear the negative indicator
		MOV	A,VARB			; Scale Positive Number
		ANL	A,#01h			;
		MOV	VARB,A			; and save
		JMP	XSEND			; Jump to send data
						;
XNEGOUT:	SETB	NEGVAL			; Set the Negative Value bit
		MOV	A,#00h			; Load A with 00h
		CLR	C			;
		SUBB	A,VARA			; Subtract X Lo
		JNC	XAXUNFLO		; Jump if there is No underflow
						;
		INC	VARB			;
XAXUNFLO:	MOV	VARA,A			; Save modified X Lo
		MOV	A,#02h			; Load A with 02h
		CLR	C			;
		SUBB	A,VARB			; Subtract X Hi
		MOV	VARB,A			; and save
						;
XSEND:		CALL	SENDHEAD  		; Send header
		MOV	A,#1Fh			;
		CALL	SENDCHAR		;
		JB	NEGVAL,XIND		; Jump if Negative Value
						;
		MOV	A,#2Bh			; Send '+'
		CALL	SENDCHAR		;
		JMP	XVALSEND		;
						;
XIND:		MOV	A,#2Dh			; Send '-'
		CALL	SENDCHAR		;
						;
XVALSEND:	MOV	SCALEA,#03h		;
		MOV	SCALEB,#0E8h		;
		CALL	BA2V			;
		MOV	R1,VARB			;
		MOV	A,VARB			;
		CALL	SENDCHAR		;
		MOV	A,VARC			;
		CALL	SENDCHAR		;
		MOV	A,VARD			;
		CALL	SENDCHAR		;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
		CALL	SENDCRC			;
		JB	LCDLOCAL,GETXEND	;
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'X =         '		;
		DB	03h			;
		MOV	A,#44h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	LCDDELAY		;
		JB	NEGVAL,XLCDIND		; Jump if Negative Value
						;
		MOV	A,#2Bh			; Send '+'
		CALL	WRITETOLCD		;
		JMP	XLCDSEND		;
						;
XLCDIND:	MOV	A,#2Dh			; Send '-'
		CALL	WRITETOLCD		;
XLCDSEND:	MOV	A,R1			;
		CALL	WRITETOLCD		;
		MOV	A,VARC			;
		CALL	WRITETOLCD		;
		MOV	A,VARD			;
		CALL	WRITETOLCD		;
		JMP	XFIN			;
						;
GETXERR:	ORL	CONTSTATHI,#01h		; Set Status for I2C error
		CALL	SENDHEAD		; Send Header
		CALL	SENDCRC			; and CRC
		JB	LCDLOCAL,GETXEND	;
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Failed      '		;
		DB	03h			;
						;
XFIN:		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getXaxis        '	;
		DB	03h		  	;
GETXEND:	RET				;
;
;--------------------------------------------------------------------------
;	>> MG01YOUT <<
;--------------------------------------------------------------------------
;
MG01YAXIS:	ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		CLR	LASTBYTE		;
		CLR	NOACK	  		; Reset I2C error flag
		CALL	STARTBIT		;
		MOV	A,#20h			; Write magnetometer address 20h
		CALL	SENDBYTE		;
		MOV	A,#03h			; Select X Axis Hi register
		CALL	SENDBYTE		;
		CALL	STARTBIT	  	;
		MOV	A,#021h		  	; Write magnetometer address + Read
		CALL	SENDBYTE	  	;
		CALL	RCVBYTE			;
		MOV	VARB,I2CRXBUF		; Get X Axis High
		SETB	LASTBYTE		; Signal Last BYte Read
		CALL	RCVBYTE			;
		MOV	VARA,I2CRXBUF		; Get X Axis Lo
		CALL	STOPBIT			;
		JNB	NOACK,YPOL		; If no errors jump
						;
		JMP	GETYERR			;
						;
YPOL:		MOV	A,VARB			; Get X High
		ANL	A,#02h			; Mask bit 9
		JZ	YNEGOUT			; Jump if a negative number
						;
		CLR	NEGVAL			; Clear the negative indicator
		MOV	A,VARB			; Scale Positive Number
		ANL	A,#01h			;
		MOV	VARB,A			; and save
		JMP	YSEND			; Jump to send data
						;
YNEGOUT:	SETB	NEGVAL			; Set the Negative Value bit
		MOV	A,#00h			; Load A with 00h
		CLR	C			;
		SUBB	A,VARA			; Subtract X Lo
		JNC	YAXUNFLO		; Jump if there is No underflow
						;
		INC	VARB			;
YAXUNFLO:	MOV	VARA,A			; Save modified X Lo
		MOV	A,#02h			; Load A with 02h
		CLR	C			;
		SUBB	A,VARB			; Subtract X Hi
		MOV	VARB,A			; and save
						;
YSEND:		CALL	SENDHEAD  		; Send header
		MOV	A,#1Fh			;
		CALL	SENDCHAR		;
		JB	NEGVAL,YIND		; Jump if Negative Value
						;
		MOV	A,#2Bh			; Send '+'
		CALL	SENDCHAR		;
		JMP	YVALSEND		;
						;
YIND:		MOV	A,#2Dh			; Send '-'
		CALL	SENDCHAR		;
						;
YVALSEND:	MOV	SCALEA,#03h		;
		MOV	SCALEB,#0E8h		;
		CALL	BA2V			;
		MOV	R1,VARB			;
		MOV	A,VARB			;
		CALL	SENDCHAR		;
		MOV	A,VARC			;
		CALL	SENDCHAR		;
		MOV	A,VARD			;
		CALL	SENDCHAR		;
		MOV	A,#1Fh		  	;
		CALL	SENDCHAR	  	; Send US
		CALL	SENDCRC			;
		JB	LCDLOCAL,GETYEND	;
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Y =         '		;
		DB	03h			;
		MOV	A,#44h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	LCDDELAY		;
		JB	NEGVAL,YLCDIND		; Jump if Negative Value
						;
		MOV	A,#2Bh			; Send '+'
		CALL	WRITETOLCD		;
		JMP	YLCDSEND		;
						;
YLCDIND:	MOV	A,#2Dh			; Send '-'
		CALL	WRITETOLCD		;
YLCDSEND:	MOV	A,R1			;
		CALL	WRITETOLCD		;
		MOV	A,VARC			;
		CALL	WRITETOLCD		;
		MOV	A,VARD			;
		CALL	WRITETOLCD		;
		JMP	YFIN			;
						;
GETYERR:	ORL	CONTSTATHI,#01h		; Set Status for I2C error
		CALL	SENDHEAD		; Send Header
		CALL	SENDCRC			; and CRC
		JB	LCDLOCAL,GETYEND	;
						;
		MOV	A,#40h			; 2nd line of LCD
		CALL	SETLCDDISP		;
		CALL	SENDSTRING		; Display instrument type on LCD
		DB	'Failed      '		;
		DB	03h			;
						;
YFIN:		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getYaxis        '	;
		DB	03h		  	;
GETYEND:	RET				;
;
;--------------------------------------------------------------------------
;	>> MG01GETTEMP <<
;--------------------------------------------------------------------------
;
MG01GETTEMP:	MOV	A,#98h			; Set Magnetometer LM73 I2C
		CALL	LM73READ		; Read Temperature
		JNB	NEGVAL,MAG01TPOS	; Jump if temperature negative
						;
		MOV	VARA,A			; Save negative Value
		MOV	A,#00h			; Load A with 00h
		CLR	C			;
		SUBB	A,VARA			; and subtract value to convert
						;
MAG01TPOS:	MOV	VARA,A			; Save value
						;
		ANL	CONTSTATHI,#80h		; Clear Status
		ANL	CONTSTATLO,#00h		;
		CALL	SENDHEAD  		; Send header
		MOV	A,#1Fh			;
		CALL	SENDCHAR		;
						;
		JB	LCDLOCAL,MAG01SIGN	; Test if in local mode
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'getTemperature  '	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Temp     C  '		;
		DB	03h		  	;
		MOV	A,#45h			; 2nd line of LCD
		CALL	SETLCDDISP		;
						;
MAG01SIGN:	JB	NEGVAL,MAG01IND		; Jump if Negative Value
						;
		MOV	A,#2Bh			; Send '+'
		CALL	SENDCHAR		;
		JB	LCDLOCAL,MAG01VALSEND	;
						;
		CALL	WRITETOLCD		;
		JMP	MAG01VALSEND		;
						;
MAG01IND:	MOV	A,#2Dh			; Send '-'
		CALL	SENDCHAR		;
		JB	LCDLOCAL,MAG01VALSEND	;
						;
		CALL	WRITETOLCD		;
MAG01VALSEND:	MOV	A,VARA			;
		MOV	B,#100d			; Load Divisor with 100
		DIV	AB			; Divide A by B
		MOV	R4,A			; Save 100s
		MOV	A,B			; Get remainder
		MOV	B,#10d			; Load Divisor with 10
		DIV	AB			; Divide A by B
		MOV	R3,A			; Save 10s
		MOV	A,R4			; Recover 100s
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		JB	LCDLOCAL,MAGLCD10	; Test if in local mode
						;
		CALL	WRITETOLCD		;
MAGLCD10:	MOV	A,R3			;
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		JB	LCDLOCAL,MAGLCDUNIT	; Test if in local mode
						;
		CALL	WRITETOLCD		;
MAGLCDUNIT:	MOV	A,B			; Recover Units
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		JB	LCDLOCAL,MAGLCDFIN	; Test if in local mode
						;
MAGLCDFIN:	CALL	WRITETOLCD		;
		MOV	A,#1Fh			; Send US
		CALL	SENDCHAR		;
		CALL	SENDCRC			;
		RET				;
						;
;
;--------------------------------------------------------------------------
;	>> DISCOVER <<
;--------------------------------------------------------------------------
;
DISCOVER:	JB	LCDLOCAL,NODISLCD	;
						;
		MOV	A,#00h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'Discover        '	;
		DB	03h		  	;
		MOV	A,#40h			; Set LCD Write Address
		CALL	SETLCDDISP		;
		CALL	SENDSTRING	  	;
		DB	'            '		;
		DB	03h		  	;
						;
NODISLCD:	MOV	R0,CONTADD	  	; Get Address
WAITLOOP:	CALL	DELAY100	  	; Call 100ms delay
		CALL	DELAY100		;
		DEC	R0		  	;
		CJNE	R0,#00h,WAITLOOP  	;
				 	  	;
		CALL	PING		  	; Jump to Send PING
					  	;
		RET				;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVV                                                                                     VVV
;VVV                               Interrupt ROUTINES                                    VVV
;VVV                                                                                     VVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
;
;	*************************************************************************
;     	* UARTINT - UART Receive Interrupt Routine (Execution time approx 31us) *
;     	* 0023h	    							       	*
;     	*		Uses the Shadow Data Pointer to place data into        	*
;	*		the received data buffer. Buffer size 2k bytes         	*
;	*		from 000000h to 0007FFh in external ram	              	*
;    	*       							       	*
;	*		10 Second Timeout Not implemented		       	*
;   	*                                            		               	*
;    	*************************************************************************
;
UARTINT:	JNB	TI,RXCHAR	  	; UART Interupt Routine
					  	; Jump if RI flag caused interupt
		CLR	TI		  	; Reset Interupt Flag
		CLR	P3.5		  	; Turn off RS485 TX Driver
		SETB	BUFEMPTY	 	; Set Buffer Empty Flag
		RETI			  	; Return from interupt
					  	;
RXCHAR:		PUSH	ACC			; Save accumulator
		MOV	A,#01h			; Select Shadow Data Pointer
		MOV	DPCON,A			;
					  	;
		MOV 	RXDATABUF,SBUF		; Store Data from UART
		MOV	A,RXDATABUF	  	; Get data with parity in MSB
		ANL	A,#7Fh			; Mask Parity bit
		MOV	CALCPAR,PSW	  	; Store parity calculated from data
		ANL	CALCPAR,#01h		; and mask other bits in register
					  	;
		MOV	A,RXDATABUF	  	; Get data with parity
		JBC	0E7h,PARHIGH		; Test MSB of A for Parity
					  	; and clear for 7 bit data
		MOV	RXDATABUF,A	  	; Parity is = 0, Save Data
		MOV	A,#00h	  		; Make A RX parity Register
		JMP	PARTEST			; Jump to test parity
					  	;
PARHIGH:	MOV	RXDATABUF,A	  	; Parity is = 1, Save Data
		MOV	A,#01h	  		; Make A RX parity Register
					  	;
PARTEST:	XRL	A,CALCPAR	  	; Compare received and calculated parity
		JZ	TESTSTART	  	; If parity correct A is = 00h Jump
					  	;
		SETB	PARITYFLAG	  	; Set Parity Error Flag
		JMP	STPCOMS			; Parity Error, end routine
					  	;
TESTSTART:	MOV	A,RXDATABUF	  	; Get data
		CJNE	A,#02h,TESTBACT		; and test for STX (02h) character
					  	;
		JMP	STRTCOMMS	  	; If STX received jump
					  	;
TESTBACT:	JNB	BUFACTV,CLRRI		; Test if in active buffering mode
					  	; Jump to end if not
		CJNE	A,#04h,SAVECHAR		; Test received data for EOT
					  	; Jump to save if not
		JMP	EOSTRING	  	; Jump to stop routine if end of
					  	; string is detected
					  	;
SAVECHAR:	MOVX	@DPTR,A			; Save character in comms buffer
		INC 	DPTR		  	; then inc DPTR
		MOV	A,DPH		  	; Get DPH in A
		CJNE	A,#08h,CLRRI		; Test for buffer limit (2k), jump if ok
					  	;
		SETB	BUFORERR	  	; Set buffer over run error flag
		JMP	STPCOMS			; If buffer full, stop routine
					  	;
EOSTRING:	MOVX	@DPTR,A			; Save char in comms buffer
		SETB	RXSTRGAV	  	; Set the received string data
					  	; available
STPCOMS:	CLR	BUFACTV	  		; Make buffer inactive
		JMP	CLRRI		  	; Jump to end
					  	;
STRTCOMMS:	MOV	DPP,#00h	  	; Reset buffer pointer
		MOV	DPH,#00h	  	;
		MOV	DPL,#00h	  	;
		SETB	BUFACTV			; Raise buffer active flag
					  	;
CLRRI:	 	MOV	A,#00h			;
		MOV	DPCON,A   	  	; Rst bit 0 of DPCON select main DPTR
		CLR	RI		  	; Clear RI bit in scon
		POP	ACC		  	; Restore the Accumulator
		RETI			  	; Return
;
;     ***************************************************************************
;     * INTERVALINT - Time Interval Counter Interrupt Routine 		      	*
;     * 0053h	    							     	*
;     *								       	      	*
;     *                                            		             	*
;     ***************************************************************************
;
INTERVALINT:	JNB	LOGEN,TIMERINTEND 	; Time Interval Counter Interupt 0053h
					  	; Jump if logging not active
		SETB	TIMERFLAG		;
TIMERINTEND:	ANL	TIMECON,#0FBh		; Reset Interupt Bit
		RETI				; Return
						;
;
;
;     ***************************************************************************
;     * TIMER0INT - Timer 0 Interrupt Routine 		    		  	*
;     * 000Bh	    							     	*
;     *								       	      	*
;     *                                            		             	*
;     ***************************************************************************
;
TIMER0INT:	SETB	T0FLAG			;
		CLR	TR0			; Stop timer 0
		MOV	TH0,#0FAh		; Reset timer counter
		MOV	TL0,#89h		; values
		SETB	TR0			; Restart timer 0
		RETI				; Return
						;
;
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVV                                                                                     VVV
;VVV                                   SUBROUTINES                                       VVV
;VVV                                                                                     VVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
;
;
;	***********************************************************************
;	* TESTSTRING - Tests receive input buffer and returns EOT address in  *
;	*	       ENDOFBUFHI and ENDOFBUFLO			      *
;	*								      *
;	*	       Tests if string is short and CRC is correct	      *
;	*	       Sets STRINGERR if tests fail			      *
;	*	       Puts received address in RCVDADD           	      *
;	***********************************************************************
						;
TESTSTRING:	MOVX	A,@DPTR		  	; Get character from buffer
		CJNE	A,#04h,TRYNEXT	  	; Test for EOT
					  	;
		JMP	TESTSHORT	  	; Jump if end of buffer found
					  	;
TRYNEXT:	INC	DPTR		  	; If not EOT look for next
		JMP	TESTSTRING	  	;
					  	;
TESTSHORT:	MOV	A,DPH		  	;
		CJNE	A,#00h,NOTSHORT   	; Test if DPH>0 if position of EOT
					  	; is not too short jump to continue
		MOV	A,DPL		  	;
		CJNE	A,#0Ah,CARRYTEST  	; Test if DPL is less than 10
					  	;
CARRYTEST:	JNC	NOTSHORT	  	; If DTPR>000Ah continue
					  	;
LOOKFORNEXT:	SETB	STRINGERR		; Set string error flag
		JMP	ERROREND	  	; Jump to end early
					  	;
NOTSHORT:	CALL	DECDPTR		  	; If position of EOT valid
		CALL	DECDPTR		  	; make DPTR mark the CRC
		CALL	DECDPTR			;
		CALL	DECDPTR			;
		MOV	ENDOFBUFHI,DPH    	; and save
		MOV	ENDOFBUFLO,DPL    	;
		MOV	DPH,#00h	  	; Reset DPTR to start of buffer
		MOV	DPL,#00h	  	;
		MOV	CRCHI,#0FFh		; Initialise CRC
		MOV	CRCLO,#0FFh		;
						;
ADDCRC:		MOVX	A,@DPTR		  	; Get character from buffer
		CALL	CRCCALC			;
		INC	DPTR		  	; Increment Pointer
		MOV	A,DPH		  	; Test end found
		CJNE	A,ENDOFBUFHI,ADDCRC 	;
					  	;
		MOV	A,DPL		  	;
		CJNE	A,ENDOFBUFLO,ADDCRC 	;
					  	;
		MOVX	A,@DPTR		  	; Get CRC HI - Hi Nibble
		MOV	R7,A		  	;
		INC	DPTR		  	;
		MOVX	A,@DPTR		  	; Get CRC HI - Lo Nibble
		MOV	R6,A		  	;
		CALL	ASCII2HEX	  	;
		CJNE	A,CRCHI,INVCRC  	; If CRC incorrect jump
					  	;
		INC	DPTR			;
		MOVX	A,@DPTR		  	; Get CRC LO - Hi Nibble
		MOV	R7,A		  	;
		INC	DPTR		  	;
		MOVX	A,@DPTR		  	; Get CRC LO - Lo Nibble
		MOV	R6,A		  	;
		CALL	ASCII2HEX	  	;
		CJNE	A,CRCLO,INVCRC  	; If CRC incorrect jump
		JMP	STRINGADD	  	; If CRC ok jump to test address
					  	;
INVCRC:		SETB	STRINGERR		; Set string error flag
		JMP	ERROREND	  	; Jump to end early
					  	;
STRINGADD:	MOV	DPP,#00h	  	; Reset DPTR to start of buffer
		MOV	DPH,#00h	  	;
		MOV	DPL,#00h	  	;
		MOVx	A,@DPTR		  	; Get Address High nibble
		MOV	R7,A		  	; Save
		CALL	CHKHEX		  	; Test if valid character
		JB	VALIDHEX,GETADDLO 	; If ok jump to continue
					  	;
		SETB	STRINGERR		; Set string error flag
		JMP	ERROREND	  	; Jump to end early
						;
GETADDLO:	INC	DPTR		  	; Point at Address Low nibble
		MOVx	A,@DPTR		  	; Get Address High nibble
		MOV	R6,A		  	; Save
		CALL	CHKHEX		  	; Test if valid character
		JB	VALIDHEX,STORRCVADD  	; If ok jump to continue
					  	;
		SETB	STRINGERR		; Set string error flag
		JMP	ERROREND	  	; Jump to end early
						;
STORRCVADD:	CALL	ASCII2HEX	  	; Convert Address Bytes to Hex
		MOV	RCVDADD,A		; Save received address
						;
ERROREND:	RET				;
						;
;
;	***********************************************************************
;	* GETFUNCTION - Reads Commandbase and Commandcode from buffer         *
;	*               saves values and test for valid hex characters        *
;	*	        Sets STRINGERR if tests fail			      *
;	*	                  	      				      *
;	***********************************************************************
						;
GETFUNCTION:	JB	LCDLOCAL,GETFUN1	; Jump if in local mode
		MOV	A,#4Ch			; Point to location on 2nd line
		CALL	SETLCDDISP	  	; of LCD
					  	;
GETFUN1:	CALL	READBYTE	 	; Get Commandbase from buffer
		JB	VALIDHEX,SAVEMF   	; If ok jump to continue
					  	;
		SETB	STRINGERR		; Set error flag
		JMP	CMDERR		  	; Jump to end
					  	;
SAVEMF:		MOV	CODEBASE,A	  	; Save Main Function Code
		MOV	A,R7			; Get CB in ASCII
		JB	LCDLOCAL,GETF1		;
						;
		CALL	WRITETOLCD		; and send to LCD
GETF1:		MOV	A,R6			;
		JB	LCDLOCAL,GETF2		;
						;
		CALL	WRITETOLCD		;
GETF2:		CALL	READBYTE	  	; Get Commandcode from buffer
		JB	VALIDHEX,SAVESF   	; If ok jump to continue
					  	;
		SETB	STRINGERR		; Set error flag
		JMP	CMDERR		  	; Jump to end
					  	;
SAVESF:		MOV	CMDCODE,A	  	; Save Sub Function Code
		JB	LCDLOCAL,CMDERR		; Jump if in local mode
						;
		MOV	A,R7			; Get CC in ASCII
		JB	LCDLOCAL,GETF3		;
						;
		CALL	WRITETOLCD		; and send to LCD
GETF3:		MOV	A,R6			;
		JB	LCDLOCAL,CMDERR		;
						;
		CALL	WRITETOLCD		;
CMDERR:		RET				; Return
						;
;
;	***********************************************************************
;	* SENDVAL - Converts the hex value of A into two ASCII chars	      *
;	*	    and uses ASCII values to update CRC			      *
;	*								      *
;	*		Sends the two characters up the UART		      *
;	*		Does not change the value of A           	      *
;	***********************************************************************
						;
SENDVAL:				  	;
		PUSH 	ACC		  	;
		SWAP 	A		  	;
		CALL 	HEX2ASCII	  	;
		CALL 	SENDCHAR 	  	; send high nibble
		POP 	ACC	 	  	;
		PUSH 	ACC		  	;
		CALL 	HEX2ASCII	  	;
		CALL 	SENDCHAR 	  	; send low nibble
		POP 	ACC		  	;
		RET			  	;
;
;	***********************************************************************
;	* SENDCHAR - Sends Character in A to the RS485 UART with Even Parity  *
;	* 								      *
;	*    		                                                      *
;	***********************************************************************
						;
SENDCHAR:	PUSH	ACC			;
		JNB 	BUFEMPTY,$        	; Loop until TX buffer empty
					  	; When empty
		CLR 	BUFEMPTY	  	; Clear buffer empty flag (make not empty)
		JB	SENDNOCRC,MISSCRC	; If SENDNOCRC bit is set do not update CRC
						;
		CALL	CRCCALC			; Update CRC
MISSCRC:	CLR	SENDNOCRC		; Reset skip CRC update flag
		ANL	A,#7Fh	          	; Mask MSB A
		MOV	C,P		  	; Load MSB A with Acc Parity from PSW
		MOV	0E7h,C		  	; via C flag
		SETB	P3.5		  	; Enable RS485 TX Driver
		MOV 	SBUF,A		  	; Move A to serial data buffer to send
		POP 	ACC		 	;
		RET			  	;
;
;	***********************************************************************
;	* SNDDECIBYTE - Sends Hex Value in A as three digit ASCII Decimal     *
;	*  		to the RS485  		      			      *
;	* 								      *
;	*    		                                                      *
;	***********************************************************************
						;
SNDDECIBYTE:	PUSH	ACC			;
		MOV	B,#100d			; Load Divisor with 100
		DIV	AB			; Divide A by B
		MOV	R4,A			; Save 100s
		MOV	A,B			; Get remainder
		MOV	B,#10d			; Load Divisor with 10
		DIV	AB			; Divide A by B
		MOV	R3,A			; Save 10s
		MOV	A,R4			; Recover 100s
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		MOV	A,R3			;
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		MOV	A,B			; Recover Units
		ADD	A,#30h			; Make ASCII
		CALL	SENDCHAR		;
		POP	ACC			;
		RET				;
						;
;
;	***********************************************************************
;	* SENDHEAD - Sends Response Header to RS485	                      *
;	* 	           		         		              *
;	***********************************************************************
						;
SENDHEAD:	MOV	A,#16h		  	;
		CALL	SENDCHAR	  	; Send Syn
		MOV	A,#16h		  	;
		CALL	SENDCHAR	  	; Send Syn
		MOV	A,#16h		  	;
		CALL	SENDCHAR	  	; Send Syn
		MOV	A,#02h		  	;
		CALL	SENDCHAR	  	; Send STX
					  	;
		MOV	CRCHI,#0FFh		; Initialise CRC
		MOV	CRCLO,#0FFh		;
						;
 		MOV	A,CONTADD	  	;
		CALL	SENDVAL		  	; Send Controller Address
				 	  	;
		MOV	A,CODEBASE	  	;
		CALL	SENDVAL		  	; Send Command Code
					  	;
		MOV	A,CMDCODE	  	;
		CALL	SENDVAL		  	; Send Command Function
					  	;
		MOV	A,CONTSTATHI		; Send top 8 bits of status word
		CALL	SENDVAL			;
						;
		MOV	A,CONTSTATLO	  	;
		CALL	SENDVAL		  	; Send lower 8 bits of Status word
						;
		RET			  	;
						;
;
;	***********************************************************************
;	* SENDCRC - Send CRC from cumulative data                	      *
;	* 	           		         			      *
;	***********************************************************************
						;
SENDCRC:	MOV	A,CRCHI		  	; Get CRC Hi Data
		SWAP 	A		  	;
		CALL 	HEX2ASCII	  	;
		SETB	SENDNOCRC		; Disable CRC Update in SENDCHAR
		CALL 	SENDCHAR 	  	; send high nibble
		MOV	A,CRCHI		  	;
		CALL 	HEX2ASCII	  	;
		SETB	SENDNOCRC		; Disable CRC Update in SENDCHAR
		CALL 	SENDCHAR 	  	; send low nibble
						;
		MOV	A,CRCLO			; Get CRC Low Data
		SWAP 	A		  	;
		CALL 	HEX2ASCII	  	;
		SETB	SENDNOCRC		; Disable CRC Update in SENDCHAR
		CALL 	SENDCHAR 	  	; send high nibble
		MOV	A,CRCLO	 	  	;
		CALL 	HEX2ASCII	  	;
		SETB	SENDNOCRC		; Disable CRC Update in SENDCHAR
		CALL 	SENDCHAR 	  	; send low nibble
						;
		MOV	A,#04h		  	; Send EOT
		CALL	SENDCHAR	  	;
		MOV	A,#0Dh		  	; Send CR
		CALL	SENDCHAR	  	;
		MOV	A,#0Ah		  	; Send LF
		CALL	SENDCHAR	  	;
		RET				;
					  	;
;
;	***********************************************************************
;	* STARTBIT - Sends I2C start Bit to initiate a message                *
;	* 	     Take SDA Low while SCL Hi 		       		      *
;	*    		                                                      *
;	***********************************************************************
						;
STARTBIT:	SETB	MDE		  	; Enable SDA Line for Output
		CLR	NOACK		  	; Reset ACK Error Flag
		CLR	MCO		  	; Make SCL Lo so that SDA can move
		CALL 	I2CDELAY	  	;
		SETB	MDO		  	; Make SDA Hi
		CALL	I2CDELAY	 	;
		SETB	MCO		  	; Then take SCL Hi
		CALL	I2CDELAY	  	;
		CLR	MDO		  	; and take SDA low to signify Start
		CALL	I2CDELAY	  	;
		RET			  	;
					  	;
;
;	***********************************************************************
;	* STOPBIT - Sends I2C Stop Bit to end message                         *
;	* 	    Take SDA Hi while SCL Hi                                  *
;	*    		                                                      *
;	***********************************************************************
						;
STOPBIT:	SETB	MDE		  	; Enable SDA Line for Output
		CLR	MCO		  	; Make SCL Lo so that SDA can move
		CALL 	I2CDELAY	  	;
		CLR	MDO		  	; Make SDA Lo
		CALL	I2CDELAY	  	;
		SETB	MCO		  	; Then take SCL Hi
		CALL	I2CDELAY	  	;
		SETB	MDO 		  	; Make SDA Hi
		CALL 	I2CDELAY	  	;
		RET			  	;
					  	;
;
;	***********************************************************************
;	* SENDBYTE - Sends 8 Bits in Acc to the Slave                         *
;	* 	   			  		       		      *
;	*    		                                                      *
;	***********************************************************************
						;
SENDBYTE:	PUSH	ACC			;
		MOV	BITCNT,#08h	  	; Set bit counter
		SETB	MDE		  	; Enable SDA Line for Output
		CLR	MCO	 	  	; Make SCL Low
		CALL	I2CDELAY	  	;
					  	;
SENDBIT:	RLC	A		  	; Put MSB into carry flag to send
		MOV	MDO,C		  	; Put data onto SDA Line
		CALL	I2CDELAY	  	;
		CALL	I2CCLOCK	  	;
		DJNZ	BITCNT,SENDBIT	  	; Decrement Bit Counter and loop until
					  	; all 8 bits sent
		CLR	MDE		  	; Release SDA to receive Ack from slave
		SETB	MCO		  	; Clock Ack from Slave
		CALL	I2CDELAY	  	;
		JNB	MDI,NEXT	  	; Check for Ack
					  	;
		SETB	NOACK		  	; If no Ack received set flag
NEXT:		CLR	MCO		  	; Make SCL Low
		CALL	I2CDELAY	  	;
		POP	ACC 			;
		RET			  	;
					  	;
;
;	***********************************************************************
;	* RCVBYTE - Receives one Byte in I2CRXBUF from I2C Slave     	      *
;	* 	           		         			      *
;	*    		                                                      *
;	***********************************************************************
						;
RCVBYTE:	MOV	BITCNT,#08h	  	; Set bit counter
		CLR	MDE		  	; Enable SDA for Input
		CLR	MCO		  	; Make SCL Lo
		CALL	I2CDELAY	  	; Allow bus settling time
					  	;
RCVBIT:		CALL	I2CCLOCK	  	; Clock Data from Slave
		MOV	C,MDI		  	; Read Data into Carry
		RLC	A		  	; Save in ACC Shift Register
		DJNZ	BITCNT,RCVBIT	  	; Decrement Bit counter and Loop
					  	; until all 8 bits received
		MOV	I2CRXBUF,A        	; Save Data
					 	;
		SETB	MDE		  	; Make SDA output
		CALL	I2CDELAY	  	;
		JB	LASTBYTE,ACKFAIL  	;
					  	;
		CLR	MDO		  	; Not last byte send Ack
		CALL	I2CDELAY	  	;
		SJMP	CLOCKACK	  	;
					  	;
ACKFAIL:	SETB	MDO		  	; Last Byte Send Nack
		CALL	I2CDELAY	  	;
CLOCKACK:	CALL	I2CCLOCK	  	; Clock Ack/Nack to Slave
 		RET			  	;
					  	;
;
;	***********************************************************************
;	* I2CCLOCK - Sends Clock to I2C SCL Line	            	      *
;	* 	           		         		              *
;	***********************************************************************
						;
I2CCLOCK:	SETB	MCO		  	; Set SCL
		CALL	I2CDELAY	  	; Wait
		CLR	MCO		  	; Clear SCL
		CALL	I2CDELAY	  	; Wait
		RET			  	;
					  	;
;
;	***********************************************************************
;	* READEEPROM - Read 128 bytes from 24LC512 EEPROM via I2C             *
;       * MODULE - I2C address of the EEPROM (controller = A0h)	              *
;	* EEPROMH - Holds Start Address High Byte			      *
;	* EEPROML - Holds Start Address Low BYte		              *
;	* Moves data to 01000h - 0107Fh in XRAM. NOACK set if no I2C ACK      *
;	* 	           		         			      *
;	***********************************************************************
						;
READEEPROM:	CLR	LASTBYTE  	  	; Clear LASTBYTE Flag
		CLR	NOACK			; Clear No Ack flag
		CALL	STARTBIT	  	;
		MOV	A,MODULE	  	; Set 24LC512 Address to Write
		CALL	SENDBYTE	  	;
		MOV	A,EEPROMH	  	; Set page to read
		CALL	SENDBYTE	  	;
		MOV	A,EEPROML	  	;
		CALL	SENDBYTE	  	;
					  	;
		CALL	STARTBIT	  	; End I2C Write
		MOV	A,MODULE	  	; 24LC512 Address to Read
		INC	A			;
		CALL	SENDBYTE	  	;
		MOV	DPP,#00h	  	;
		MOV	DPH,#10h      	  	; Set Pointer for XRAM
		MOV	DPL,#00h	  	;
		MOV	XRCOUNT,#7Fh	  	; Set bytes counter
PGREAD:		CALL	RCVBYTE		  	; Get data
		MOV	A,I2CRXBUF	  	; Save Data
		MOVX	@DPTR,A		  	;
		INC	DPTR		  	; Increment pointer
		DJNZ	XRCOUNT,PGREAD	  	; Decrement Counter and loop
					  	; until all 128 bytes read
		SETB	LASTBYTE	  	; Mark last byte
		CALL	RCVBYTE		  	; Get data
		MOV	A,I2CRXBUF	  	; Save last byte of page
		MOVX	@DPTR,A		  	;
		CALL	STOPBIT		  	;
		RET			  	;
					  	;
;
;	***********************************************************************
;	* WRITEEEPROM - Writes 128 bytes to 24LC512 EEPROM via I2C	      *
;	* Module - Holds EEPROM I2C address				      *
;	* EEPROMH - Holds Start Address High Byte			      *
;	* EEPROML - Holds Start Address Low BYte		              *
;	* Moves data from 01000h - 0107Fh to XRAM. EEPROMERR set if no ACK    *
;	* 	           		         			      *
;	***********************************************************************
						;
WRITEEEPROM:	CLR	NOACK			; Clear No ACK Flag
		CALL	STARTBIT	  	;
		MOV	A,MODULE	  	; Set 24LC512 Address to Write
		CALL	SENDBYTE	  	;
		MOV	A,EEPROMH	  	; Set page to read
		CALL	SENDBYTE	  	;
		MOV	A,EEPROML	  	;
		CALL	SENDBYTE	  	;
		MOV	DPP,#00h	  	;
		MOV	DPH,#10h          	; Set Pointer for XRAM
		MOV	DPL,#00h	  	;
		MOV	XRCOUNT,#80h	  	; Set bytes counter
PGWRITE:	MOVX	A,@DPTR		  	; Send data to 24LC512
		CALL	SENDBYTE	  	;
		INC	DPTR		  	; Increment pointer
		DJNZ	XRCOUNT,PGWRITE		; Loop until 128 bytes sent
					  	;
		CALL	STOPBIT		  	;
		MOv	R3,#10h		  	; Set counter intial values 6ms delay
WRCYCLE:	MOV	R4,#0FFh	  	;
		DJNZ	R4,$		  	; Inner Loop until R4 is zero
					  	;
		DJNZ	R3,WRCYCLE	  	; Outer Loop until R3 is Zero
					  	;
		RET			  	;
					  	;
;
;	***********************************************************************
;	* GETDATE - Gets Date from RTC and places in DATE, MONTH, YEAR        *
;	* 	           		         			      *
;	***********************************************************************
						;
GETDATE:	CLR	LASTBYTE	  	;
		CALL	STARTBIT	  	;
		MOV	A,#0D0h		  	; DS1307 Address + Write
		CALL	SENDBYTE	  	;
		MOV	A,#04h		  	; Select Date register
		CALL	SENDBYTE	  	;
		CALL	STARTBIT	  	; Stop Write and start read
		MOV	A,#0D1h		  	; DS1307 Address + Read
		CALL	SENDBYTE	  	;
		CALL	RCVBYTE		  	; Get Date
		MOV	DATE,I2CRXBUF	  	; Save in Date store
		CALL	RCVBYTE		  	; Get Month
		MOV	MONTH,I2CRXBUF	  	; Save in Month store
		CALL	RCVBYTE		  	; Get Year
		MOV	YEAR,I2CRXBUF	  	; Save in Year
		CALL	RCVBYTE			; Get Register 07
		CALL	RCVBYTE			; Get tens of century
		MOV	CENTTEN,I2CRXBUF	; Save
		SETB	LASTBYTE	  	; Signal last byte to read
		CALL	RCVBYTE			; Get units of century
		MOV	CENTUNIT,I2CRXBUF	; Save
		CALL	STOPBIT		  	;
		RET			  	;
					  	;
;
;	***********************************************************************
;	* GETTIME - Gets Time from RTC and places in SECOND, MINUTE, HOURS    *
;	* 	           		         			      *
;	***********************************************************************
						;
GETTIME:	CLR	LASTBYTE	  	;
		CALL	STARTBIT	  	;
		MOV	A,#0D0h		  	; DS1307 Address + Write
		CALL	SENDBYTE	  	;
		MOV	A,#00h		  	; Select Seconds register
		CALL	SENDBYTE	  	;
		CALL	STARTBIT	  	; Stop Write and start read
		MOV	A,#0D1h		  	; DS1307 Address + Read
		CALL	SENDBYTE	  	;
		CALL	RCVBYTE		  	; Get Seconds
		MOV	SECOND,I2CRXBUF   	; Save in store
		CALL	RCVBYTE		  	; Get Minutes
		MOV	MINUTE,I2CRXBUF   	; Save in store
		SETB	LASTBYTE	  	; Signal last byte to read
		CALL	RCVBYTE		  	; Get Hours
		MOV	HOURS,I2CRXBUF	  	; Save in store
		CALL	STOPBIT		  	;
				          	;
		RET			  	;
						;
;
;	***********************************************************************
;	* GETADCVAL - Samples the ADC Channel Specified in A		      *
;	* 								      *
;	*    		                                                      *
;	***********************************************************************
						;
GETADCVAL:	ANL	A,#0Fh		  	; MaskLower Nibble of channel data
		ANL	ADCCON2,#0F0h	  	; Reset lower nibble of ADCCON2 register
		ORL	ADCCON2,A	  	; Combine to set channel
		NOP			  	; Allow to settle
		SETB	SCONV		  	; Start Conversion
		JB	SCONV,$		  	; Loop until conversion ended
					  	;
		RET			  	; Data in ADCDATAH and ADCDATAL
					  	; Return
					  	;
;
;	***********************************************************************
;	* CLEARLCD - Clears LCD DDRAM and set pointer to 1st char on 1st      *
;	*            Line of display				              *
;	*    		                                                      *
;	***********************************************************************
						;
CLEARLCD:	MOV	R1,#50h		  	; Set counter for 80 characters
		CALL	STARTBIT		; Start I2C command
		MOV	A,#76h			; Send I2C address
		CALL	SENDBYTE		;
		MOV	A,#00h			;
		CALL	SENDBYTE		; LCD Command to write instruction
		MOV	A,#80h			;
		CALL	SENDBYTE		; Set DDRAM address to 00h
		CALL	STOPBIT			;
						;
LCDLOOP:	CALL	STARTBIT		;
		MOV	A,#76h			; Send I2C address
		CALL	SENDBYTE		;
		MOV	A,#40h			;
		CALL	SENDBYTE		; LCD Command to write data
		MOV	A,#0A0h			;
		CALL	SENDBYTE		; Write blank to display
		CALL	STOPBIT			;
						;
		DEC	R1			;
		MOV	A,R1			; Test Counter
		JNZ	LCDLOOP			; Loop until 80 characters
						;
		CALL	STARTBIT		;
		MOV	A,#76h			; Send I2C address
		CALL	SENDBYTE		;
		MOV	A,#00h			;
		CALL	SENDBYTE		; LCD Command
		MOV	A,#80h			;
		CALL	SENDBYTE		; Set DDRAM address to 00h
		CALL	STOPBIT			;
						;
		RET				; Display Cleared
						;
;
;	***********************************************************************
;	* WRITETOLCD - Sends character in A to LCD		   	      *
;	* 								      *
;	*    		                                                      *
;	***********************************************************************
					  	;
WRITETOLCD:	PUSH	ACC			;
		CALL	STARTBIT		;
		MOV	A,#76h			; Send I2C address of LCD
		CALL	SENDBYTE		;
		MOV	A,#40h			;
		CALL	SENDBYTE		; Send LCD Command to write data
		POP	ACC			;
		CJNE	A,#5Bh,$+3		; Correct ASCII to suit
						; LCD Character set
		JNC	SENDLCD			;
						;
		ORL	A,#80h			; Set bit 7 if U/C char or Number
SENDLCD:	CALL	SENDBYTE		; Write character to display
		CALL	STOPBIT			;
		RET				;
						;
;
;	***********************************************************************
;	* SETLCDDISP - Sets the character position on the LCD display  	      *
;	* 	       A hold the address 00h to 4Fh 			      *
;	*    		                                                      *
;	***********************************************************************
					  	;
SETLCDDISP:	PUSH	ACC			;
		CALL	STARTBIT	  	;
		MOV	A,#76h		  	; Send I2C address
		CALL	SENDBYTE	  	;
		MOV	A,#00h		  	;
		CALL	SENDBYTE	  	; LCD Command
		POP	ACC		  	;
		ORL	A,#80h		  	; Set Bit 7 to suit LCD register
		CALL	SENDBYTE	  	; Set DDRAM Address
		CALL	STOPBIT		  	;
	 	RET			  	;
;
;	***********************************************************************
;	* SENDSTRING - 	Sends String to LCD	       			      *
;	*								      *
;	***********************************************************************
						;
SENDSTRING:	MOV	R3,DPH		  	;
		MOV	R4,DPL		  	;
		POP	STACKHI		  	; POP and store Stack Hi Value
		POP	STACKLO		  	; POP and store Stack LO Value
		MOV	R0,DPCON	  	;
		ANL	DPCON,#0FEh	  	; Select Main Data Pointer
		MOV	DPH,STACKHI	  	; Load Data Pointer with PC Data
		MOV	DPL,STACKLO	  	;
GETSTRNGCHAR:	CLR	A		  	; Set A for no offset
		MOVC	A,@A+DPTR	 	; Get Data in A
		CJNE	A,#03h,WRLCD	  	; If not end of text jump
				  	  	;
		JMP	ENDOFSTRING	  	; End of string found finish routine
					  	;
WRLCD:		CALL	WRITETOLCD	  	; Send A to LCD
		INC	DPTR		  	; Move data pointer for next char
		MOV	A,#01h		  	;
		ADD	A,STACKLO	  	;
		MOV	STACKLO,A	  	;
		JNC	NOCARRY1	  	; Jump if no carry
					  	;
		INC	STACKHI		  	; If Carry set on Stack LO Inc Hi
NOCARRY1:	SJMP	GETSTRNGCHAR	  	; Loop
					  	;
ENDOFSTRING:	MOV     DPL,R4		  	;
		MOV	DPH,R3		  	;
		MOV	DPCON,R0	  	;
		PUSH	STACKLO		  	; Put modified PC on Stack
		PUSH	STACKHI		  	;
					  	;
		RET			  	; Return
					  	;
;
;	***********************************************************************
;	* LCDVAL - Converts the hex value of A into two ASCII chars	      *
;	*	   and writes to LCD					      *
;	*								      *
;	***********************************************************************
						;
LCDVAL:		PUSH	ACC			;
		SWAP 	A		  	;
		CALL 	HEX2ASCII	  	;
		CALL 	WRITETOLCD 	  	; send high nibble
		POP 	ACC	 	  	;
		PUSH 	ACC		  	;
		CALL 	HEX2ASCII	  	;
		CALL 	WRITETOLCD 	  	; send low nibble
		POP 	ACC		  	;
		RET			  	;
;
;	***********************************************************************
;	* LCDDELAY - Delays 10ms                                   	      *
;	* 	           		         			      *
;	***********************************************************************
						;
LCDDELAY:	MOV	EEPROMH,#10h		; Load outer loop count = 16
FIRSTLOOP:	MOV	EEPROML,#0E8h		; Load inner loop count	= 233
SECLOOP:	DEC	EEPROML			; Dec inner count
		NOP				;
		NOP				;
		MOV	A,EEPROML		; Test if loop counter = 0
		JNZ	SECLOOP			; Loop if not
						;
		DEC	EEPROMH			; Dec outer count
		MOV	A,EEPROMH		; Test if outer count = 0
		JNZ	FIRSTLOOP		; If not loop
						;
		RET				; End
						;
;
;	***********************************************************************
;	* LONGDELAY - Delays 0.5s                                   	      *
;	* 	           		         			      *
;	***********************************************************************
						;
LONGDELAY:	CLR	RS1			; Start timer
		SETB	RS0			;
		MOV	R0,#14h		  	; Set loop counter
DISPHOLD:	CALL	DELAY100	  	;
		DJNZ	R0,DISPHOLD	  	; Loop until timeout
						;
		RET				;
						;
;
;	***********************************************************************
;	* I2CDELAY - Delay for I2C Transmission		   	              *
;	* 	           		         		              *
;	***********************************************************************
						;
I2CDELAY:	NOP			  	; Initial CALL is 1.43uS
		NOP			  	; Six NOP is 4.14uS
		NOP			  	; and Return is 1.43uS
		NOP			  	; Total 7uS
		NOP			  	; Should produce about 65kBit/s
		NOP			  	;
		RET			  	;
						;
;
;	***********************************************************************
;	* DELAY100 - Delays 100ms                                   	      *
;	* 	           		         			      *
;	***********************************************************************
					  	;
DELAY100:	MOV	EEPROMH,#35h		; Load outer loop count = 100
INNERLOOP:	MOV	EEPROML,#0E8h		; Load inner loop count	= 233
DECLOOP:	DEC	EEPROML			; Dec inner count
		NOP				;
		NOP				;
		MOV	A,EEPROML		; Test if loop counter = 0
		JNZ	DECLOOP			; Loop if not
						;
		DEC	EEPROMH			; Dec outer count
		MOV	A,EEPROMH		; Test if outer count = 0
		JNZ	INNERLOOP		; If not loop
						;
		RET				; End
						;
;
;	***********************************************************************
;	* CHKHEX - Tests Character in A to determine if it is a Hex (0-9,A-F) *
;	*		                          			      *
;	*		VALIDHEX bit set if character is valid Hex	      *
;	*                                                                     *
;	***********************************************************************
						;
CHKHEX:		PUSH 	ACC		  	; Save Accumulator
		CJNE	A,#30h,$+3	  	; Test if A<30h
		JC	NONHEX		  	; Jump if A<30h
					  	;
		CJNE	A,#47h,$+3	  	; Test if A>47h
		JNC	NONHEX		  	; Jump if A=>47
					  	;
		CJNE	A,#3Ah,$+3       	; Test if A<3Ah
		JC	REALHEX		  	; Jump if A<3Ah
					  	;
		CJNE	A,#41h,$+3	  	; Test if A>41h
		JNC	REALHEX		  	; Jump if A>41h
					  	;
NONHEX:		CLR	VALIDHEX	  	; Clear flag if not hex character
		SJMP	HEXEXIT		  	; Jump to Exit
					  	;
REALHEX:	SETB	VALIDHEX	  	; Set flag if A<39h or A>41h
HEXEXIT:	POP 	ACC               	; Restore Accumulator
		RET			  	; and Return
					  	;
;
;	***********************************************************************
;	* HEX2ASCII - Converts the lower nibble of A into ASCII hex	      *
;	* 								      *
;	*    		                                                      *
;	***********************************************************************
						;
HEX2ASCII:	ANL 	A,#00Fh			; Mask lower nibble of A
		CJNE 	A,#00Ah,$+3	  	; Test if A < 10d
						;
		JC 	IO0030			; Jump if 0 - 9
						;
		ADD 	A,#07h		  	; Add 7h if A - F
IO0030: 	ADD 	A,#30h		  	; Make ASCII by adding 30h
		RET			  	;
;
;	***********************************************************************
;	* HEXINASCII - Converts the hex value of A into two ASCII chars	      *
;	*	       and writes to buffer			      	      *
;	*								      *
;	***********************************************************************
						;
HEXINASCII:				  	;
		PUSH 	ACC		  	;
		SWAP 	A		  	;
		CALL 	HEX2ASCII	  	;
		MOVX	@DPTR,A 	  	; High nibble
		INC	DPTR			;
		POP 	ACC	 	  	;
		PUSH 	ACC		  	;
		CALL 	HEX2ASCII	  	;
		MOVX	@DPTR,A 	  	; Low nibble
		INC	DPTR			;
		POP 	ACC		  	;
		RET			  	;
;
;	***********************************************************************
;	* ASCII2HEX - Converts two ASCII characters to a hex data byte        *
;	*		                          			      *
;	*		Upper nibble of hex in ASCII in R7		      *
;	*		Lower nibble of hex in ASCII in R6		      *
;	*                                                                     *
;	*		Uses R5 					      *
;	*								      *
;	*		Hex output in Acc				      *
;	***********************************************************************
						;
ASCII2HEX:	MOV	A,R7		  	; Get Upper nibble ASCII
		CJNE	A,#41h,$+3	  	; Set carry flag if A<41h (0 to 9)
		JC	SUB30		  	; Jump
					  	;
		CLR	C			;
		SUBB	A,#07h		  	; Subtract 07h to correct
SUB30:		CLR	C			;
		SUBB	A,#30h		  	; Subtract 30h to make 4 bit binary
		SWAP	A	 	  	; Swap the nibbles of A
		ANL	A,#0F0h		  	; Mask upper nibble
		MOV 	R5,A		  	; Save A with top nibble set
		MOV	A,R6		  	; Get lower nibble ASCII
		CJNE	A,#41h,$+3	  	; Set carry flag if A<41h (0 to 9)
		JC	REMOVE30	  	; Jump
					  	;
		CLR	C		  	;
		SUBB	A,#07h		  	; Subtract 07h to correct
REMOVE30:	CLR	C		  	;
		SUBB	A,#30h		  	; Subtract 30h to make 4 bit binary
		ANL	A,#0Fh		  	; Mask to nibble
		ORL	A,R5		  	; OR to get hex in A
		RET			  	; Return
						;
;
;	***********************************************************************
;	* DECI2HEX - 	Converts decimal in three ASCII characters	      *
;	*		to a hex data byte       	 		      *
;	*		                          			      *
;	*		100s in R7			   	       	      *
;	*		 10s in R6				              *
;	*                 1s in R5                                            *
;	*		 						      *
;	*		Hex output in Acc				      *
;	***********************************************************************
						;
DECI2HEX:	MOV	A,R7	  		;
		CLR	C			;
		SUBB	A,#30h		  	; Subtract 30h to make 4 bit binary
		MOV	B,#100d			;
		MUL	AB			;
		Mov	R4,A			;
						;
		MOV	A,R6	  		;
		CLR	C			;
		SUBB	A,#30h		  	; Subtract 30h to make 4 bit binary
		MOV	B,#10d			;
		MUL	AB			;
		ADD	A,R4			;
		MOV	R4,A			;
						;
		MOV	A,R5	  		;
		SUBB	A,#30h		  	; Subtract 30h to make 4 bit binary
		ADD	A,R4			;
		RET				;
						;
;
;	***********************************************************************
;	* BCD2HEX - Converts 4 character Binary Coded Decimal 0000 to 2500 mV *
;	* 	    to 12 bit decimal for D2A				      *
; 	* 	    1000's = VARD 					      *
;	* 	     100's = VARC 					      *
;       *             10's = VARB 					      *
;	*	       1's = VARA 					      *
;       *	    Output High Byte = ADH				      *
;	*	    Output Low  Byte = ADL				      *
;	*	     			  				      *
;	***********************************************************************
						;
BCD2HEX:	MOV	ADH,#00h		; Clear OUtput registers
		MOV	ADL,#00h		;
						;
		MOV	R2,#66h			; Multiply 1000's by 6666h
		MOV	R1,#66h			;
		MOV	R0,VARD			;
		CALL	MULT16BIT		;
		MOV	R2,#0Ah			; Multiply 100's by 0A3Dh
		MOV	R1,#3Dh			;
		MOV	R0,VARC			;
		CALL	MULT16BIT		;
		MOV	R2,#01h			; Multiply 10's by 0106h
		MOV	R1,#06h			;
		MOV	R0,VARB			;
		CALL	MULT16BIT		;
		MOV	R2,#00h			; Multiply 1's by
		MOV	R1,#1Ah			;
		MOV	R0,VARA			;
		CALL	MULT16BIT		;
						;
		MOV	A,ADL			; Divide answer by 16 start low byte
		SWAP	A			; Mov Top nibble of A into lower nibble
		ANL	A,#0Fh			; Clear top nibble
		MOV 	ADL,A			; Save divided by 16 ADL
						;
		MOV	A,ADH			; Get High byte
		SWAP	A			; Put bottom nibble of high byte into
		ANL	A,#0F0h			; high nibble and clear bottom nibble
		ORL	A,ADL			; OR to move low nibble Hi byte to Lo Byte
		MOV	ADL,A			; and save Lo byte
						;
		MOV	A,ADH			; Get High byte
		SWAP	A			; Move high nibble to low nibble
		ANL	A,#0Fh			; Clear top nibble
		MOV	ADH,A			; and save
		RET				;
						;
;
;	***********************************************************************
;	* READBYTE - Gets two ASCII bytes from buffer and outputs             *
;	* 	     a single hex byte in A. Error checks validity            *
;	* 	           		         		              *
;	***********************************************************************
						;
READBYTE:	INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get Module High nibble
		MOV	R7,A		  	; Save
		CALL	CHKHEX		  	; Test if valid character
		JB	VALIDHEX,GETBYTEL 	; If ok jump to continue
					  	;
		JMP	EARLYEND	  	; Errored data jump to restart
					  	;
GETBYTEL:	INC	DPTR		  	; Point at Module Low nibble
		MOVx	A,@DPTR		  	; Get Page Low nibble
		MOV	R6,A		  	; Save
		CALL	CHKHEX		  	; Test if valid character
		JB	VALIDHEX,SAVEBYTE 	; If ok jump to continue
					  	;
		JMP	EARLYEND	  	;
					  	;
SAVEBYTE:	CALL	ASCII2HEX	  	; Get module address and save
EARLYEND:	RET			  	;
					  	;
;
;	***********************************************************************
;	* BA2V - Converts 12 bit A2D value to millivolts displayed in ASCII   *
;	* VALUE IN VARIABLES VARB AND VARA 				      *
; 	* BCD VOLTS IN VARIABLES VARA, VARB, VARC, AND VARD		      *
;	* FORMATTED "0000" TO "2500"					      *
; 	* USES R2, R3, R4, PLUS MEMORY STORAGE ADH AND ADL		      *
;	*								      *
;	***********************************************************************
						;
BA2V:		MOV	ADH,VARB		; Put variables into temporary storage
		MOV	ADL,VARA		;
						;
		CALL	AD2VD			; DIVIDE VALUE BY DIGIT VALUE
		MOV	VARA,R2			; SAVE VOLT DIGIT
		CALL	AD2VM			; MULTIPLY REMAINING BY 10
						;
		CALL	AD2VD			; DIVIDE VALUE BY DIGIT VALUE
		MOV	VARB,R2			; SAVE VOLT DIGIT
		CALL	AD2VM			; MULTIPLY REMAINING BY 10
						;
		CALL	AD2VD			; DIVIDE VALUE BY DIGIT VALUE
		MOV	VARC,R2			; SAVE VOLT DIGIT
		CALL	AD2VM			; MULTIPLY REMAINING BY 10
						;
		CALL	AD2VD			; DIVIDE VALUE BY DIGIT VALUE
		MOV	VARD,R2			; SAVE VOLT DIGIT
						;
		ORL	VARA,#30h		; Convert to ASCII
		ORL	VARB,#30h		;
		ORL	VARC,#30h		;
		ORL	VARD,#30h		;
						;
 		RET				; and end
						;
AD2VD:		MOV	R2,#0			; CLEAR COUNT
AD2V1:		MOV	A,ADL			; GET LOW BYTE OF A/D VALUE
		CLR	C			; NEEDED FOR SUBTRACTION
		SUBB	A,SCALEB		; LOWER BYTE OF 1638D
		MOV	R4,A			; TEMPORARY SAVE
		MOV	A,ADH			; GET HIGH BYTE OF A/D VALUE
		SUBB	A,SCALEA		; UPPER BYTE OF 1638D
		MOV	R3,A			; TEMPORARY SAVE
		JC	AD2VX			; SUBTRACTED TOO MUCH, DONE WITH THIS LOOP
						;
		MOV	ADL,R4			; NO ROLL UNDER, SAVE SUBTRACTED A/D VALUE
		MOV	ADH,R3			;
		INC	R2			; INDICATE ONE MORE VOLT
		JMP	AD2V1			;
AD2VX:		RET				;
						;
AD2VM:		MOV	B,#10			; MULTIPLY BY 10
		MOV	A,ADL			; GET LOWER BYTE OF A/D VALUE
		MUL	AB			; A*B=B:A
		PUSH	B			;
		MOV	ADL,A			;
		MOV	B,#10			; MULTIPLY BY 10
		MOV	A,ADH			;
		MUL	AB			; A*B=B:A
		POP	B			; GET CARRY
		ADD	A,B			;
		MOV	ADH,A			;
		RET				;
 						;
;
;	***********************************************************************
;	* READDECI - Gets three ASCII bytes from buffer and outputs           *
;	* 	     a single hex byte in A.                                  *
;	* 	           		         		              *
;	***********************************************************************
						;
READDECI:	INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get 100s
		MOV	R7,A		  	; Save
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get 10s
		MOV	R6,A		  	; Save
		INC	DPTR		  	;
		MOVx	A,@DPTR		  	; Get 1s
		MOV	R5,A		  	; Save
		CALL	DECI2HEX		; Convert to Hex Byte
		RET				;
						;
;
;	***********************************************************************
;	* DECDPTR - Decrement Data Pointer		             	      *
;	* 	           		         			      *
;	***********************************************************************
						;
DECDPTR:	PUSH	ACC		  	; Save A
					  	;
		MOV	A,DPL		  	; Get DPL in A
		CLR	C		  	;
		SUBB	A,#01h	 	  	; Decrement DPL
		JC	GODECDPH	  	; If underflow jump to dec DPH
					  	;
		MOV	DPL,A		  	; Save DPL
		JMP	GOEND		  	; And end
			  	  	  	;
GODECDPH:	MOV	DPL,A		  	; Save DPL
		MOV	A,DPH		  	; Get DPH in A
		CLR	C		  	;
		SUBB	A,#01h	  	  	; Decrement DPH
		JC	GODECDPP	  	; If underflow jump to dec DPP
					  	;
		MOV	DPH,A		  	; Save DPH
		JMP	GOEND		  	;
					  	;
GODECDPP:	MOV	DPH,A		  	;
		MOV	A,DPP		  	;
		CLR	C		  	;
		SUBB	A,#01h	          	; Decrement DPP
		MOV	DPP,A		  	;
GOEND:		POP	ACC		  	; Restore A
		RET			  	;
					  	;
;
;	***********************************************************************
;	* MULT16BIT - 16 bit multiply routine scaled for 2500mV input to      *
;	*	      produce no overflow from 16 bit output		      *
;	*								      *
;	*	      Adds output to ADH and ADL 			      *
;	* 	    					 		      *
;	*	      R0 = 8 bit Input Variable 			      *
;	*	      R1 = 16 bit Multiply Factor Lo Byte	  	      *
;	*	      R2 = 16 bit Multiply Factor Hi Byte		      *
;	*	      R3 = Carry Register				      *
;	*	      R4 = 16 bit Output Lo Byte			      *
;	*	      R5 = 16 bit Output Hi Byte			      *
;	*								      *
;	***********************************************************************
						;
MULT16BIT:	MOV	A,R0			; Get input variable
		MOV 	B,R1			; Get Mult Lo
		MUL	AB			; Multiply
		MOV	R4,A			; Save to Lo Byte
		MOV	R3,B			; Save Carry
		MOV	A,R0			; Get input variable
		MOV	B,R2			; Get Mult Hi
		MUL	AB			; Multiply
		ADD 	A,R3			; Add Carry
		MOV 	R5,A			; Save to Hi Byte
						;
		MOV	A,ADL			; Get Output Low byte
		ADD	A,R4			; Add Lo byte to output
		JNC	NOOVERFLO		; Jump if no overflow
						;
		MOV	ADL,A			; Save Output Low Byte
		INC	ADH			; Increment ADH
		JMP	CALCHB			; Jump to complete hi byte
						;
NOOVERFLO:	MOV	ADL,A			; Save Output Low Byte
CALCHB:		MOV	A,ADH			; Get ADH
		ADD	A,R5			; Add to ADH
		MOV	ADH,A			; and save in output High Byte
		RET				;
						;
;
;	***********************************************************************
;	* CRCCALC - Modifies the CRC according to the data byte passed in A   *
;	* Uses CRC-CCITT algorithm in native mode (No reflections and         *
; 	* polynomial (1021h). 16 bit CRC CRCHI and CRCLO initialized by       *
;	* calling routine to FFFFh.                                           *
;	*								      *
;	***********************************************************************
						;
CRCCALC:	PUSH	ACC			; Save data
		CLR	RS1			; Select Register Bank 1
		SETB	RS0			;
		MOV	R0,A			;
		MOV	A,R1			;
		PUSH	ACC			;
		MOV	R1,#08h			; Set shift loop counter to 8
						;
POLYTEST:	MOV	A,R0		        ; Get CRC Data
		XRL	A,CRCLO			; Exclusive OR Data with CRC Low Byte
		ANL	A,#01h			; Mask all except LSB
		JNZ	XORPOLY			; Test LSB and jump if set
						;
		MOV	A,R0			; Get Data
		CLR	C			;
		RRC	A			; Shift Data Right
		MOV	R0,A			; and save
						;
		MOV	A,CRCLO			; Get CRC Low Byte
		CLR	C			;
		RRC	A			; Shift CRC LOw Right
		MOV	CRCLO,A			; and save
						;
		MOV	A,CRCHI			; Get CRC Hi Byte
		CLR	C			;
		RRC	A			; Shift CRC Hi Right
		JC	SETMSBCRC		; Jump to Set CRC Low MSB
						;
		MOV	CRCHI,A			; Save CRC Hi
		ANL	CRCLO,#7Fh		; Reset CRC Low MSB
		JMP	DECCRCCNT		; Jump to decrement counter
						;
SETMSBCRC:	MOV	CRCHI,A			; and save CRC Hi
		ORL	CRCLO,#80h		; Set MSB CRC LOw
		JMP	DECCRCCNT		; Jump to decrement counter
						;
XORPOLY:	MOV	A,R0			; Get Data
		CLR	C			;
		RRC	A			; Shift Data Right
		MOV	R0,A			; and Save
						;
		MOV	A,CRCLO			; Get CRC Low Byte
		CLR	C			;
		RRC	A			; Shift CRC LOw Right
		MOV	CRCLO,A			; and save
						;
		MOV	A,CRCHI			; Get CRC Hi Byte
		CLR	C			;
		RRC	A			; Shift CRC Hi Right
		JC	MSBSETCRC		; Jump to Set CRC Low MSB
						;
		MOV	CRCHI,A			; Save CRC Hi
		ANL	CRCLO,#7Fh		; Reset CRC Low MSB
		JMP	POLYXOR			; Jump to decrement counter
						;
MSBSETCRC:	MOV 	CRCHI,A			; and save CRC Hi
		ORL	CRCLO,#80h		; Set MSB CRC LOw
						;
POLYXOR:	MOV	A,CRCHI			; Get CRC Hi
		XRL	A,#10h			; Exclusive OR with 10h
		MOV	CRCHI,A			; and save
		MOV	A,CRCLO			; Get CRC Low
		XRL	A,#21h			; Exclusive OR with 21h
		MOV	CRCLO,A			; and save
DECCRCCNT:	DJNZ	R1,POLYTEST		; Decrement Loop Counter
						; Loop until eight shifts have been made
		POP	ACC			;
		MOV	R1,A			;
		POP	ACC			;
		RET				; CRC Updated, Return to normal
						;
;
;	************************************************************************
;	* CALCMAXBLOCK - Calculates the total size of XML in 512 byte blocks   *
;	* 		 Sets CFGBLKMAXHI and CFGBLKMAXLO		       *
;	*		 If EOT value not set in EEPROM finds EOT address and  *
;	*		 Writes this to EEPROM				       *
;	* 	       						               *
;	************************************************************************
						;
CALCMAXBLOCK:	MOV	CFGBLKMAXHI,#00h	; Clear 512 byte Block Counter
		MOV	CFGBLKMAXLO,#00h	;
		MOV	MODULE,#0A0h	  	; Set module to controller EEPROM Address
		MOV	VARA,PROMMAP		;
		MOV	A,VARA			;
						;
TESTFORMODULE:	ANL	A,#01h			; Test bit 0
		JZ	CMNOPROM		; Jump if no EEPROM
						;
CMGETPROM:	MOV	EEPROMH,#00h	  	; Set pointer to read page 0
		MOV	EEPROML,#00h	  	;
		CLR	NOACK			; Clear error flag
		CALL	READEEPROM	  	; Read first 128 bytes of EEPROM to Buffer
						;
		MOV	DPP,#00h		; Initialise Buffer Pointer
		MOV	DPH,#10h		; to look for EOT Address
		MOV	DPL,#03h		;
		CALL	READBYTE		; Get EOT Hi
		MOV	VARB,A			; Save EOT Hi
		JZ	GETEOTLO		;
						;
CALC512BLK:	MOV	A,VARB			;
		CLR	C			; Clear Carry Flag
		RRC	A			; Divide by 2 to get 512 byte block size
		CLR	C			;
		ADD	A,CFGBLKMAXLO		; Add to Config block counter
		MOV	CFGBLKMAXLO,A		; Save
		JNC	CMNOPROM		;
						;
		INC	CFGBLKMAXHI		; and increment Hi byte if carry set
						;
CMNOPROM:	INC	MODULE			; Select next EEPROM
		INC	MODULE			;
		MOV	A,MODULE		; Test for end
		CJNE	A,#0B0h,ROTMAPBYTE	; Loop if not end
						;
		MOV	A,CFGBLKMAXLO		; Decrement Max Block
		CLR	C			;
		SUBB	A,#01h			;
		MOV	CFGBLKMAXLO,A		; Save
		JNC	CORRECTMAX		; Test for underflow
						;
		DEC	CFGBLKMAXHI		; Decrement Hi byte if necessary
CORRECTMAX:	JMP	CALCEOTEND		; Registers set now exit
						;
ROTMAPBYTE:	MOV	A,VARA			;
		CLR	C			;
		RR	A			;
		MOV	VARA,A			;
		JMP	TESTFORMODULE		;
						;
GETEOTLO:	CALL	READBYTE		; Get EOT Lo
		JNZ	CALC512BLK		; If EOT address not 0000h Jump
						;
		MOV	EEPROMH,#02h		; If EOT needs to be written
BIGEOTLOOP:	MOV	EEPROML,#00h		; EOT must be found
		CLR	NOACK			;
		CALL	READEEPROM		;
						;
		MOV	DPP,#00h		; Set pointer
		MOV	DPH,#10h		;
		MOV	DPL,#00h		;
TESTCHAREOT:	MOVX	A,@DPTR			; Get data
		CJNE	A,#03h,GOGETNEXT4EOT	; Jump if not EOT
						;
		JMP	FILLINEOT		;
						;
GOGETNEXT4EOT:	INC	DPTR			;
		MOV	A,DPL			;
		CJNE	A,#80h,TESTCHAREOT	; Test end of first/third 128 bytes
						;
		MOV	EEPROML,#80h		; Next half page
		CLR	NOACK			;
		CALL	READEEPROM		;
						;
		MOV	DPP,#00h		; Set pointer
		MOV	DPH,#10h		;
		MOV	DPL,#00h		;
EOTNEXT:	MOVX	A,@DPTR			; Get data
		CJNE	A,#03h,TRYEOTNEXT	; Jump if not EOT
						;
		JMP	FILLINEOT		;
						;
TRYEOTNEXT:	INC	DPTR			;
		MOV	A,DPL			;
		CJNE	A,#80h,EOTNEXT		; Test end of second/fourth 128 bytes
						;
		INC	EEPROMH			; Select next 256 byte page
		MOV	A,EEPROMH		;
		CJNE	A,#00h,BIGEOTLOOP	; Loop
						;
		MOV	VARC,#02h		; Set EOT position to 0201h
		MOV	VARD,#01h		;
		JMP	PATCHEEPROM		; EOT not found make XML Valid by
						; putting dummy EOT position in
						; EEPROM
						;
FILLINEOT:	MOV	VARC,EEPROMH		; EOT Address Hi Byte
		MOV	VARD,DPL		; EOT Address LO Byte
						;
PATCHEEPROM:	MOV	EEPROMH,#00h		; If EOT needs to be written
		MOV	EEPROML,#00h		; EOT must be found
		CLR	NOACK			;
		CALL	READEEPROM		; Read 128 byte block
						;
		MOV	DPP,#00h		; Set pointer
		MOV	DPH,#10h		;
		MOV	DPL,#04h		;
						;
		MOV	A,VARC			; Get EOT Hi byte
		CALL	HEXINASCII		; Write to buffer
		MOV	A,VARD			; Get EOT Lo byte
		CALL	HEXINASCII		; Write to buffer
						;
		MOV	EEPROMH,#00h		; Set pointers for write
		MOV	EEPROML,#00h		;
		CLR	NOACK			;
		CALL	WRITEEEPROM		; Copy buffer back to EEPROM
		JMP	CMGETPROM 		;
						;
CALCEOTEND:	RET				; Exit the routine
						;
;
;	***********************************************************************
;	* GETCRCANDEOT - Finds the EOT character in an EEPROM   	      *
;	* 		 Calculates the CRC for the data        	      *
;	*		 Exits with CRC in CRCHI and CRCLO		      *
;	*		 and EOT address in EEPROMH and EEPROML		      *
; 	*		 EEPROM Module is set by calling routine 	      *
;	***********************************************************************
						;
GETCRCANDEOT:	MOV	EEPROMH,#02h	  	; Set page address
		MOV	EEPROML,#00h	  	;
		MOV	CRCHI,#0FFh		; Initialise CRC
		MOV	CRCLO,#0FFh		;
		CLR	EOTERR			; Clear error flag
						;
NEXTPROMPAGE:	CLR	NOACK			; Clear Flag
		CALL	READEEPROM	  	; Read EEPROM to Buffer
		JNB	NOACK,EOTFIND      	; If EEPROM data ok jump
					  	;
		CLR	NOACK		  	; Reset Flag
		JMP	ERREOT  		; Jump if EEPROM read fails
						;
EOTFIND:	MOV	DPP,#00h		; Set pointer
		MOV	DPH,#10h		;
		MOV	DPL,#00h		;
EOTLOOP1:	MOVX	A,@DPTR			; Get character
		CJNE	A,#03h,NOTEOT		; Look for EOT
						;
		JMP	EOTFOUND		; Jump if EOT Found
						;
NOTEOT:		CALL	CRCCALC			; Calculate CRC
		INC	DPTR			;
		MOV	A,DPL			; Test for end of page
		CJNE	A,#80h,EOTLOOP1		; and loop to test if not at end
						;
		MOV	EEPROML,#80h		; Point to next page
		CLR	NOACK			; Clear Flag
		CALL	READEEPROM		; Read EEPROM to buffer
		JNB	NOACK,ETXFIND		; If EEPROM data ok jump
						;
		CLR	NOACK			;
		JMP	ERREOT			;
						;
ETXFIND:	MOV	DPP,#00h		; Set pointer
		MOV	DPH,#10h		;
		MOV	DPL,#00h		;
EOTLOOP2:	MOVX	A,@DPTR			; Get character
		CJNE	A,#03h,NOTETX		; Look for EOT
						;
		JMP	EOTFOUND		; Jump if EOT Found
						;
NOTETX:		CALL	CRCCALC			; Calculate CRC
		INC	DPTR			;
		MOV	A,DPL			; Test for end of page
		CJNE	A,#00h,EOTLOOP2		; and loop to test if not at end
						;
		MOV	A,EEPROMH		; Increment 256 byte page counter
		INC	A			;
		JZ	ERREOT			; If page pointer rolls over jump
						;
		MOV	EEPROMH,A		; Save pointer
		MOV	EEPROML,#00h		; Set pointer to lower half of page
		JMP	NEXTPROMPAGE		; Try next 256 byte page
						;
ERREOT:		SETB	EOTERR			; Set flag for no EOT found
		JMP	EOTFINISH		;
						;
EOTFOUND:	MOV	A,DPL			; EOT address is in EEPROMH
		ADD	A,EEPROML		; EEPROML and DPL
		MOV	EEPROML,A		; Add DPL and EEPROML and save
EOTFINISH:	RET				;
						;
;
;	***********************************************************************
;	* LM73READ - Reads LM73 temperature in 11 bit mode                    *
;	* 	     Enters with sensor I2C write address in A		      *
;	*	     Shifts data to reduce resolution to 1deg		      *
;	*	     Output in A with NEGVAL Bit set if negative	      *
;	*		 						      *
;	***********************************************************************
						;
LM73READ:	PUSH	VARB			;
		PUSH	VARC			;
		PUSH	VARD			;
		MOV	VARB,A			; Save I2C address
		CALL	STARTBIT		; Send I2C Start bit
		MOV	A,VARB			; Recover address
		CALL	SENDBYTE		; Send address byte
		MOV	A,#00h			; Set LM73 Pointer to temperature
		CALL	SENDBYTE		;
		CALL	STOPBIT			; End pointer set routine
						;
		CALL	STARTBIT		; Start data read
		MOV	A,VARB 			; Get I2C read address
		INC	A			;
		CALL	SENDBYTE		;
		CALL	RCVBYTE			; Read a byte
		MOV	VARC,I2CRXBUF		; and save
		SETB	LASTBYTE		; Set last byte flag
		CALL	RCVBYTE			; Read byte
		MOV	VARD,I2CRXBUF		; and save
		CALL	STOPBIT			;
						;
		MOV	A,VARC			; Get data Hi
		RLC	A			; Shift Hi byte left
		JC	MAG01VNEG		; Jump if negative
						;
		CLR	NEGVAL			;
		JMP	MAG01VSET		;
						;
MAG01VNEG:	SETB	NEGVAL			;
MAG01VSET:	MOV	VARC,A			; Save
		MOV	A,VARD			;
		RLC	A			;
		JC	MAG01SETB0		; Jump to set Bit 0
						;
		ANL	VARC,#0FEh		; Reset bit 0
		JMP	MAG01B0SET		;
						;
MAG01SETB0:	ORL	VARC,#01h		; Set bit 0
MAG01B0SET:	MOV	A,VARC			; Move data to A
		POP	VARD			;
		POP	VARC			;
		POP	VARB			;
		RET				;
						;
;
;	***********************************************************************
;	* WRLOGHEAD - Writes header into RAM for logger block                 *
;	* 	       						              *
;	***********************************************************************
						;
WRLOGHEAD:	CALL	GETDATE			;
		MOV	A,CENTUNIT	  	; Log Century
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
		MOV	A,YEAR		  	; Log Year
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
		MOV	A,MONTH		  	; Log Month
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
		MOV	A,DATE		  	; Log Day
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
					  	;
		CALL	GETTIME			;
		MOV	A,HOURS		  	; Log Hours
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
		MOV	A,MINUTE	  	; Log Minutes
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
		MOV	A,SECOND	  	; Log Seconds
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
					  	;
		MOV	A,PERIODHI	  	; Log sampling period
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
		MOV	A,PERIODLO	  	; Log sampling period
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
						;
		MOV	A,BLOCKHI		; Log Block Count
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
		MOV	A,BLOCKLO		;
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
						;
		INC	DPTR		  	; Increment pointer past max blockentry
		INC	DPTR		  	; To be filled at end.
						;
		MOV	A,INSTRUMENT		; Log Instrument Type
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
		MOV	A,VERSION		; Log Instrument Version
		MOVX	@DPTR,A			;
		INC	DPTR		  	;
						;
		MOV	A,#98h			; Set temperature sensor address
		CALL	LM73READ		; Get temperature
		JB	NEGVAL,SETSIGN		; Jump if negative value
						;
		ANL	A,#7Fh			; Clear bit 7 of A
		JMP	ENDLOGHEAD		;
						;
SETSIGN:	ORL	A,#80h			; Set bit 7 of A
ENDLOGHEAD:	MOVX	@DPTR,A			; Log Temperature
		INC	DPTR			;
		RET				;
;
;	************************************************************************
;	* MAGLOGOUT - Converts 12bit Data to Signed Decimal and sends to RS485 *
;	* 	       						               *
;	************************************************************************
						;
MAGLOGOUT:	MOV	A,VARB			; Get Value High Byte
		ANL	A,#02h			; Mask bit 9
		JZ	GBXNEGOUT		; Jump if a negative number
						;
		CLR	NEGVAL			; Clear the negative indicator
		MOV	A,VARB			; Scale Positive Number
		ANL	A,#01h			;
		MOV	VARB,A			; and save
		JMP	GBXSEND			; Jump to send data
						;
GBXNEGOUT:	SETB	NEGVAL			; Set the Negative Value bit
		MOV	A,#00h			; Load A with 00h
		CLR	C			;
		SUBB	A,VARA			; Subtract X Lo
		JNC	GBXAXUNFLO		; Jump if there is No underflow
						;
		INC	VARB			;
GBXAXUNFLO:	MOV	VARA,A			; Save modified X Lo
		MOV	A,#02h			; Load A with 02h
		CLR	C			;
		SUBB	A,VARB			; Subtract X Hi
		MOV	VARB,A			; and save
						;
GBXSEND:	JB	NEGVAL,GBXIND		; Jump if Negative Value
						;
		MOV	A,#2Bh			; Send '+'
		CALL	SENDCHAR		;
		JMP	GBXVALSEND		;
						;
GBXIND:		MOV	A,#2Dh			; Send '-'
		CALL	SENDCHAR		;
						;
GBXVALSEND:	MOV	SCALEA,#03h		;
		MOV	SCALEB,#0E8h		;
		CALL	BA2V			;
		MOV	R1,VARB			;
		MOV	A,VARB			;
		CALL	SENDCHAR		;
		MOV	A,VARC			;
		CALL	SENDCHAR		;
		MOV	A,VARD			;
		CALL	SENDCHAR		;
		RET				;
;
;-----------------------------------------------------------------------------
END					  	; End of program
						;
